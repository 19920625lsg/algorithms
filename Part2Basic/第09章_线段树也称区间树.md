# 第09章 线段树
> 也称区间树，表明我们关系的是一个区间内的问题
## 9.1 什么是线段树
> 对于有一类问题，我们关系地是线段(即区间)

### 线段树的应用举例
+ 染色问题
  > ![区间染色问题1](images/第09章_区间树/区间染色问题1.png)
  > ![区间染色问题1](images/第09章_区间树/区间染色问题2.png)
  
  > 染色问题的操作步骤如下：

  | 操作               | 使用数组实现 | 使用线段树实现 |
  | ------------------ | ------------ | -------------- |
  | 染色操作(更新区间) | O(n)         | O(logn)        |
  | 查询操作(查询区间) | O(n)         | O(logn)        |
+ 区间查询问题
  > ![线段树举例](images/第09章_区间树/线段树举例1.png)
  
  > 线段树的常见操作：
  
  | 操作     | 使用数组实现 | 使用线段树实现 |
  |-------- | ------------ | -------------- |
  | 更新区间 | O(n)         | O(logn)        |
  | 查询区间 | O(n)         | O(logn)        |

### 总结：区间问题的常见操作
| 操作     | 含义 | 使用数组实现 | 使用线段树实现 |
|-------- | ------------ | -------------- | -------------- |
| 更新 | 更新区间中一个元素或者一个区间的值 | O(n)         | O(logn)        |
| 查询 | 查询一个区间[i, j]中的最大值、最小值或区间数字和 | O(n)         | O(logn)        |

显然我们应该用线段树来解决问题

### 线段树举例
> 每个节点存储地就是这个区间的特征值

![线段树含义举例](images/第09章_区间树/线段树含义举例.png)

## 9.2 线段树基础表示

### 线段树不一定是满二叉树
> 上一届的A[0...7]的例子比较特殊，区间长度为2的3次方，正满填满一棵二叉树

下面的例子中，当区间长度不是2的整数次方时，区间没法均分，线段树就不是满二叉树了
![线段树不一定是满二叉树](images/第09章_区间树/线段树不一定是满二叉树.png)

不是满二叉树，我们仍然可以用数组来表示线段树，不满的地方我们用空来在数组中表示即可

### 区间有n个元素时，线段树的数组需要多少个节点？
![区间有n个元素时线段树的数组需要多少个节点](images/第09章_区间树/区间有n个元素时线段树的数组需要多少个节点.png)

![区间有n个元素时线段树的数组需要多少个节点2](images/第09章_区间树/区间有n个元素时线段树的数组需要多少个节点2.png)

总上：
+ 如果区间有n个元素，表示线段树的数组需要4n的空间
+ 因为线段树不考虑添加元素，即区间固定，所以使用4n的静态空间即可

线段树时非满二叉树时，4n空间中多余的位置我们可以认为是null,如下图：
![线段树时非满二叉树时4n空间中多余的位置我们可以认为是null](images/第09章_区间树/线段树时非满二叉树时4n空间中多余的位置我们可以认为是null.png)

## 9.3 构建线段树
> 基于递归来做，好好体会下

```java
public SegmentTree(E[] arr, Merger<E> merger) {
    this.data = (E[]) new Object[arr.length];
    this.merger = merger;
    // 数组复制
    for (int i = 0; i < arr.length; i++) {
        data[i] = arr[i];
    }
    tree = (E[]) new Object[4 * arr.length];
    // 构建线段树
    buildSegmentTree(0, 0, data.length - 1);
}

/**
 * 创建线段树：在treeIndex的位置创建区间[l...r]的线段树
 *
 * @param treeIndex 要创建的线段树的根节点
 */
private void buildSegmentTree(int treeIndex, int l, int r) {
    assert (l <= r);
    // 递归终止条件
    if (l == r) {
        // 当只有一个元素的时候，即到了线段树的最下层叶子节点的位置
        tree[treeIndex] = data[l];
        return;
    }

    // 递归逻辑
    // 获取左孩子的索引
    int leftTreeIndex = leftChild(treeIndex);
    int rightTreeIndex = rightChild(treeIndex);
    // 确定左右区间的分界点，[leftTreeIndex, mid] [mid+1, rightTreeIndex]
    // 中间位置 当(l+r)/2会有溢出问题，，可以使用l+(r-l)/2来解决
    int mid = l + (r - l) / 2;
    buildSegmentTree(leftTreeIndex, l, mid);
    buildSegmentTree(rightTreeIndex, mid + 1, r);

    // 这里根据业务特点决定每个节点的值是sum、max、min、avg等.综合左右子树来得到父节点的数据
    tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);
}
```