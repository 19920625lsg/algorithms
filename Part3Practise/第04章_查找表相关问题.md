# 第04章 查找表相关问题

## 4.1 Set的使用 

```java
给定两个数组，编写一个函数来计算它们的交集。

示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]
说明:

输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。
```

```java
package Chapter04SetAndMap.IntersectionofTwoArrays;

import java.util.*;

/***********************************************************
 * @note      : 
 * @author    : l00379880 梁山广
 * @version   : V1.0 at 2019/8/20 15:46
 ***********************************************************/
class Solution {

    /**
     * 用retainAll方法实现求交集
     */
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> numSet = new HashSet<>();
        for (int i : nums1) {
            numSet.add(i);
        }

        Set<Integer> num2Set = new HashSet<>();

        for (int i : nums2) {
            num2Set.add(i);
        }

        // 求交集
        numSet.retainAll(num2Set);
        int[] result = new int[numSet.size()];
        int i = 0;
        for (Integer num : numSet) {
            result[i] = num;
            i++;
        }
        return result;
    }


    /**
     * 用自己的方法实现交集，核心是contains方法
     */
    public int[] intersection2(int[] nums1, int[] nums2) {

        TreeSet<Integer> record = new TreeSet<>();
        for (int num : nums1) {
            record.add(num);
        }

        TreeSet<Integer> resultSet = new TreeSet<>();
        for (int num : nums2) {
            if (record.contains(num)) {
                resultSet.add(num);
            }
        }

        int[] res = new int[resultSet.size()];
        int index = 0;
        for (Integer num : resultSet) {
            res[index++] = num;
        }

        return res;
    }


    public static void main(String[] args) {
        int[] nums1 = {4, 9, 5};
        int[] nums2 = {9, 4, 9, 8, 4};
        int[] result = new Solution().intersection2(nums1, nums2);
        System.out.println(Arrays.toString(result));
    }
}
```

## 4.2 Map的使用

```java
给定两个数组，编写一个函数来计算它们的交集。

示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]
示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [4,9]
说明：

输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
我们可以不考虑输出结果的顺序。
进阶:

```

```java
package Chapter04SetAndMap.IntersectionofTwoArrays2;

import java.util.*;

/***********************************************************
 * @note      : 
 * @author    : l00379880 梁山广
 * @version   : V1.0 at 2019/8/20 16:36
 ***********************************************************/
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        Map<Integer, Integer> num1Map = new HashMap<>();
        Set<Integer> num1Set = new HashSet<>();
        for (int i : nums1) {
            num1Map.merge(i, 1, Integer::sum);
            num1Set.add(i);
        }


        Map<Integer, Integer> num2Map = new HashMap<>();
        Set<Integer> num2Set = new HashSet<>();

        for (int i : nums2) {
            num2Map.merge(i, 1, Integer::sum);
            num2Set.add(i);
        }

        // 求交集
        num1Set.retainAll(num2Set);

        // num1Set就是交集的元素了
        List<Integer> resultList = new ArrayList<>();
        for (Integer num : num1Set) {
            int count = Math.min(num1Map.get(num), num2Map.get(num));
            for (int i = 0; i < count; i++) {
                resultList.add(num);
            }
        }

        int[] result = new int[resultList.size()];
        int i = 0;
        for (Integer num : resultList) {
            result[i] = num;
            i++;
        }
        return result;
    }

    public static void main(String[] args) {
        int[] nums1 = {1, 2, 2, 1};
        int[] nums2 = {2};
        int[] result = new Solution().intersect(nums1, nums2);
        System.out.println(Arrays.toString(result));
    }
}
```

## 4.4 Two Sum的问题

```java
定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

```java
package Chapter04SetAndMap.TwoSum;

import java.util.*;

/***********************************************************
 * @note      : 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
 * 解题思路：选定一个元素a，在剩下的元素中用二分查找法查找target-a
 * @author    : l00379880 梁山广
 * @version   : V1.0 at 2019/8/20 19:34
 ***********************************************************/

class NumObj {
    /**
     * nums中元素的下标
     */
    private int index;
    /**
     * nums中元素的值
     */
    private int value;

    public NumObj(int index, int value) {
        this.index = index;
        this.value = value;
    }

    public int getIndex() {
        return index;
    }

    public int getValue() {
        return value;
    }


    @Override
    public String toString() {
        return "NumObj{" +
                "index=" + index +
                ", value=" + value +
                '}';
    }
}

/**
 * 升序排列比较器
 */
class MyComparator implements Comparator<NumObj> {

    @Override
    public int compare(NumObj o1, NumObj o2) {
        return o1.getValue() - o2.getValue();
    }
}

public class Solution {

    /**
     * 定下一个元素，在剩下的元素里面进行二分查找
     *
     * @param nums   查找的数组
     * @param target 要求的和
     * @return 符合条件的两个元素的下标
     */
    public int[] twoSum(int[] nums, int target) {
        List<NumObj> numObjList = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            NumObj numObj = new NumObj(i, nums[i]);
            numObjList.add(numObj);
        }
        Collections.sort(numObjList, new MyComparator());

        // 返回至少 有一个元素的数组
        int[] result = {0, 0};

        for (int i = 0; i < numObjList.size(); i++) {
            NumObj numObj = numObjList.get(i);
            int valA = numObj.getValue();
            List<NumObj> numObjListTmp = new ArrayList<>(numObjList);
            numObjListTmp.remove(i);
            int index = Collections.binarySearch(numObjListTmp, new NumObj(0, target - valA), new MyComparator());
            if (index >= 0) {
                // 索引不能和当前numObj相等,而且大于0
                int indexa = numObj.getIndex();
                int indexb = numObjListTmp.get(index).getIndex();
                result[0] = Math.min(indexa, indexb);
                result[1] = Math.max(indexa, indexb);
                return result;
            }
        }
        return result;
    }

    public static void main(String[] args) {
        int[] nums = {-1, -2, -3, -4, -5};
        int target = -8;

        int[] result = new Solution().twoSum(nums, target);
        System.out.println(Arrays.toString(result));
    }
}
```

相关的题目：

+ [15. 三数之和](https://leetcode-cn.com/problems/3sum)
  ```java
  给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
  注意：答案中不可以包含重复的三元组。
  例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

  满足要求的三元组集合为：
  [
    [-1, 0, 1],
    [-1, -1, 2]
  ]
  ```
+ [18. 四数之和](https://leetcode-cn.com/problems/4sum)
  ```java
  给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

  注意：

  答案中不可以包含重复的四元组。

  示例：
  给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

  满足要求的四元组集合为：
  [
    [-1,  0, 0, 1],
    [-2, -1, 1, 2],
    [-2,  0, 0, 2]
  ]
  ```
+ [16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest)
  ```java
  给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
  例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

  与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
  ```
