# 第08章 递归和回溯
## 8.0 递归与回溯的异同

### 参考文章
+ [递归与回溯](https://blog.csdn.net/lym940928/article/details/89679157)
+ [递归与回溯的理解](https://www.cnblogs.com/fanguangdexiaoyuer/p/11224426.html)
+ [回溯和递归区别](https://blog.csdn.net/u014772862/article/details/51789015)

### 比较

|          | 递归                                                         | 回溯                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义     | 为了描述问题的某一状态，必须用到该状态的上一状态，而描述上一状态，又必须用到上一状态的上一状态……这种用自已来定义自己的方法，称为递归定义。形式如 f(n) = n*f(n-1), if n=0,f(n)=1. | 从问题的某一种可能出发, 搜索从这种情况出发所能达到的所有可能, 当这一条路走到” 尽头 “的时候, 再倒回出发点, 从另一个可能出发, 继续搜索. 这种不断” 回溯 “寻找解的方法, 称作” 回溯法 “。 |
| 不同     | 递归是一种算法结构，递归会出现在子程序中自己调用自己或间接地自己调用自己。最直接的递归应用就是计算连续数的阶乘，计算规律：n!=(n-1)!*n。 | 回溯是一种算法思想，可以用递归实现。通俗点讲回溯就是一种试探，类似于穷举，`但回溯有“剪枝”功能`，比如求和问题。给定7个数字，1 2 3 4 5 6 7，求和等于7的组合，从小到大搜索，选择1+2+3+4 =10>7，已经超过了7，之后的5 6 7就没必要在继续了，这就是一种搜索过程的优化。如果还有不清楚的可以看一下8皇后问题。 |
| 问题举例 | [玩转算法面试第7章_二叉树与递归](第07章_二叉树和递归.md)     | [玩转算法面试第8章_递归与回溯](第08章_递归和回溯.md)         |

### 举例
> 用一个比较通俗的说法来解释递归和回溯：
我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。
+ 我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，再做一次尝试，即在函数内部再调用一次函数，这就是递归的过程。
+ 这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路，这就是回溯的思想。

## 8-1 树形问题 [17.电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/) 

```txt
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
示例:

输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```
![第17号问题](images/第08章_递归与回溯/第17号问题.png)

```java
class Solution {
    // 每个按键(数组的下标)对应的可能的字符串，0和1不对应任何字符，所以这里为空
    String[] letterMap = {
            "", // 0
            "", // 1
            "abc", // 2
            "def", // 3
            "ghi", // 4
            "jkl", // 5
            "mno", // 6
            "pqrs", // 7
            "tuv",  // 8
            "wxyz"  // 9
    };

    public List<String> letterCombinations(String digits) {
        // 存储最终结果的列表
        List<String> result = new ArrayList<>();
        if ("".equals(digits)){
            return result;
        }
        findCombinations(digits, 0, "", result);
        return result;
    }

    /**
     * 寻找digits[index]匹配的字母，获得digits[0...index]对应的解
     *
     * @param digits 原始数字字符串
     * @param index 要看digits的哪一个数字
     * @param s      s保存了此时从digits[0...index-1]翻译得到的一个字母字符串
     * @param result 保存最终可能的字符串
     */
    private void findCombinations(String digits, int index, String s, List<String> result) {
        // 所有数字都遍历完了，递归退出
        if (index == digits.length()) {
            result.add(s);
            return;
        }
        // 拿到index对应的数字字符
        char c = digits.charAt(index);
        // 获取当前数字字符可能对应的键盘上的字符串
        String lettersStr = letterMap[c - '0'];
        // 第当前数字对应的字符串进行遍历拼接
        for (int i = 0; i < lettersStr.length(); i++) {
            findCombinations(digits, index + 1, s + lettersStr.charAt(i), result);
        }
    }
}
```

### [93.复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

### [131.分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)