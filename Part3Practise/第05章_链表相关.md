# 第05章 链表相关

本章的两个基础类如下
> 链表的节点类。toString()在debug时实时查看链表很有用
```java
/***********************************************************
 * @Description : 链表的节点
 * @author      : 梁山广(Liang Shan Guang)
 * @date        : 2020/1/17 22:13
 * @email       : liangshanguang2@gmail.com
 ***********************************************************/
package Chapter05LinkedList;

public class ListNode {
    public int val;
    public ListNode next;

    public ListNode(int x) {
        val = x;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        ListNode cur = this;
        while (cur != null) {
            sb.append(cur.val).append(" -> ");
            cur = cur.next;
        }
        sb.append("NULL");
        return sb.toString();
    }
}
```

> 链表的显示工具类。create用于从数据创建链表，show用于把head作为头结点的链表表示成一个字符串的形式
```java
/***********************************************************
 * @Description : 链表的显示工具类
 * @author      : 梁山广(Liang Shan Guang)
 * @date        : 2020/1/17 22:14
 * @email       : liangshanguang2@gmail.com
 ***********************************************************/
package Chapter05LinkedList;

class LinkedListTool {
    /**
     * 根据数组创建链表
     *
     * @param nums 数组
     * @return 创建的链表的头节点
     */
    public static ListNode create(int[] nums) {
        if (nums.length == 0) {
            return null;
        }
        ListNode head = new ListNode(nums[0]);
        ListNode curr = head;
        for (int i = 1; i < nums.length; i++) {
            curr.next = new ListNode(nums[i]);
            curr = curr.next;
        }
        return head;
    }

    public static void show(ListNode head) {
        ListNode curr = head;
        while (curr != null) {
            System.out.print(curr.val + " -> ");
            curr = curr.next;
        }
        System.out.println("NULL");
    }
}
```

## 5.1~5.2 [题目206 反转列表](https://leetcode-cn.com/problems/reverse-linked-list/)

```java
反转一个单链表。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```
代码实现分两步：
+ 1.初始化
  > ![反转链表之初始化](images/第05章_链表/反转链表之初始化.png)
+ 2.指针移动
  > ![反转链表之移动](images/第05章_链表/反转链表之移动.png)

```java
public class Solution {
    public ListNode reverseList(ListNode head) {
        // 当前节点的上一个节点，初始化为null，是因为所有所有的链表最后一个元素都可以看为null
        ListNode prev = null;
        // 当前节点
        ListNode curr = head;
        // 当前节点的下一个节点
        while (curr != null) {
            // 当当前节点的下一个节点不为空时
            ListNode next = curr.next;
            // 翻转当前节点，指向上一个节点
            curr.next = prev;
            // 上一个节点后移动一位
            prev = curr;
            // 当前节点后移动一位
            curr = next;
        }
        // 遍历到最后,pre指向了最后一个节点
        return prev;
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5};
        ListNode head = LinkedListTool.create(nums);
        LinkedListTool.show(head);
        ListNode headReverse = new Solution().reverseList(head);
        LinkedListTool.show(headReverse);
    }
}

/**
 * 1 -> 2 -> 3 -> 4 -> 5 -> NULL
 * 5 -> 4 -> 3 -> 2 -> 1 -> NULL
 */
```

类似的题目还有[92. 反转部分链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

```txt
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```
+ 第一步：找到待反转节点的前一个节点。
+ 第二步：反转m到n这部分。
+ 第三步：将反转的起点的next指向反转的后面一部分。
+ 第四步：将第一步找到的节点指向反转以后的头节点。
![部分反转链表](images/第05章_链表/部分反转链表.png)
```java
/***********************************************************
 * @Description : 反转链表的m~n的链表
 * @author      : 梁山广(Liang Shan Guang)
 * @date        : 2020/1/17 23:20
 * @email       : liangshanguang2@gmail.com
 ***********************************************************/
package Chapter05LinkedList.LeetCode92ReverseLinkedListPart;

import Chapter05LinkedList.LinkedListTool;
import Chapter05LinkedList.ListNode;

class Solution {

    public ListNode reverseBetween(ListNode head, int m, int n) {
        // 创建虚拟头结点,防止一些null导致的问题
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode cur = dummyHead;
        for (int i = 1; i < m; i++) {
            // 找到了m的上一个节点
            cur = cur.next;
        }
        // node.next就是要翻转的起点，mHead表示开始翻转的起点
        ListNode mHead = cur.next;
        ListNode next = null;
        ListNode pre = null;
        // 翻转m到n这一段，起点是mHead，参考206题
        for (int i = m; i <= n; i++) {
            next = mHead.next;
            mHead.next = pre;
            pre = mHead;
            mHead = next;
        }
        // m位置的节点指向n位置的下一个节点
        cur.next.next = next;
        // m前一个节点指向n位置处的节点
        cur.next = pre;
        // 返回虚拟头结点的下一个节点即新的头结点
        return dummyHead.next;
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5};
        ListNode head = LinkedListTool.create(nums);
        LinkedListTool.show(head);
        // 返回新链表的dead
        ListNode headNew = new Solution().reverseBetween(head, 2, 4);
        LinkedListTool.show(headNew);
    }
}
/**
 * 1 -> 2 -> 3 -> 4 -> 5 -> NULL
 * 1 -> 4 -> 3 -> 2 -> 5 -> NULL
 */
```

> 还有83、86、328、2、445号问题也是链表相关的问题

### [83.删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)
```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode cur = head;
        while (cur != null) {
            if (cur.next != null && cur.val == cur.next.val) {
                cur.next = cur.next.next;
            }else {
                cur = cur.next;
            }
        }
        return head;
    }

    /**
     * 1->1->2  ==> 1->2
     * [] -> []
     * [1,1,1,1] ==> [1]
     * {1,1,2,3,3}  ==> [1, 2, 3]
     */
    public static void main(String[] args) {
        int[] nums = {1,1,2,3,3};
        ListNode head = LinkedListTool.create(nums);
        LinkedListTool.show(head);
        ListNode newHead = new Solution().deleteDuplicates(head);
        LinkedListTool.show(head);
    }
}
```

### [86.分隔链表](https://leetcode-cn.com/problems/partition-list/)
> 核心思想是把小于x的节点和大于等于x的节点拆成两个链表，最后把后者连接到前者形成一条新的链表就是满足题目的链表
```java
 // 核心思想是把小于x的节点和大于等于x的节点拆成两个链表，最后把后者连接到前者形成一条新的链表就是满足题目的链表
class Solution {
    public ListNode partition(ListNode head, int x) {
        // 存储所有大于等于x的节点的链表的虚拟头结点
        ListNode bigHead = new ListNode(0);
        // 存储所有小于x的节点的链表的虚拟头结点
        ListNode smallHead = new ListNode(0);
        // 上面两个链表的指针，用于插入元素
        ListNode big = bigHead;
        ListNode small = smallHead;
        while(head != null){
            if(head.val < x){
                // 插入节点到小元素链表
                small.next = head;
                // 指针往后移动
                small = small.next;
            }else {
                // 插入节点到大元素链表
                big.next = head;
                big = big.next;
            }
            head = head.next;
        }
        // 把大元素连接到小元素链表后面
        small.next = bigHead.next;
        // 大元素链表的尾部要清空下，防止还连着些乱七八糟的节点
        big.next = null;
        // 返回小元素链表的头结点，即虚拟头结点的下一个节点
        return smallHead.next;
    }
}
```
### [328.奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)
> 和上面的第86号问题非常类似，区别在于这里是按照奇数编号和偶数编号分成了两个链表，除了if逻辑不通，其他地方完全相同
```java
/***********************************************************
 * @Description : 新建两个不同的链表，遍历一遍原链表后，分别存储奇数编号节点和偶数编号节点，最后把奇数链表连接到偶数链表即可
 * 和LeetCode第86号问题按照边界分成两个链表的思路基本一致
 * @author      : 梁山广(Liang Shan Guang)
 * @date        : 2020/1/18 18:24
 * @email       : liangshanguang2@gmail.com
 ***********************************************************/
package Chapter05LinkedList.LeetCode382OddEvenLinkedList;

import Chapter05LinkedList.ListNode;

class Solution {
    public ListNode oddEvenList(ListNode head) {
        // 奇数链表的虚拟头结点
        ListNode oddHead = new ListNode(0);
        // 偶数链表的虚拟头结点
        ListNode evenHead = new ListNode(0);
        // 上面两个链表的移动指针
        ListNode odd = oddHead;
        ListNode even = evenHead;
        int index = 0;
        while(head != null){
            if(index % 2 == 1){ // 奇数编号节点
                // 插入节点到奇数链表
                odd.next = head;
                // 移动指针往后一位
                odd = odd.next;
            }else { // 偶数编号节点
                even.next = head;
                even = even.next;
            }
            head = head.next;
            index++;
        }
        // 奇数链表连接到偶数链表后面
        even.next = oddHead.next;
        // 奇数链表的最后清空下，防止连接些乱七八糟的节点
        odd.next = null;
        return evenHead.next;
    }
}
```

### 2.

### 445


## 5.3 设立链表的虚拟头节点DummyHead可以大大简化代码逻辑
> LeetCode203号问题 Remove Linked List Elements

```txt
删除链表中等于给定值 val 的所有节点。

示例:

输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

### 不设置虚拟头结点时，需要对头结点作各种异常判断

```java
package Chapter05LinkedList.RemoveElements;

/***********************************************************
 * 反转一个单链表。
 *
 * 示例:
 *
 * 输入: 1->2->3->4->5->NULL
 * 输出: 5->4->3->2->1->NULL
 *
 * @note      : 创建pre、cur和next三个节点指针，不断移动节点来达到目的
 * @author    : l00379880 梁山广
 * @version   : V1.0 at 2019/8/21 15:23
 ***********************************************************/
public class Solution {
    public ListNode removeElements(ListNode head, int val) {
        // 每次都要更新head
        while (head != null && head.val == val) {
            // 头结点的val就是想找的val，那么就要删除头节点
            head = head.next;
        }

        // 最后的head仍然可能为空
        if (head == null) {
            // 需要对头结点判空
            return null;
        }

        ListNode curr = head;
        while (curr.next != null) {
            if (curr.next.val == val) {
                // 把current.next这个节点释放掉
                curr.next = curr.next.next;
            } else {
                // 没有找到符合的节点就继续向下找
                curr = curr.next;
            }
        }
        return head;
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 6, 4, 5, 6};
        int val = 6;
        ListNode head = LinkedListTool.create(nums);
        LinkedListTool.show(head);
        ListNode headRemove = new Solution().removeElements(head, val);
        LinkedListTool.show(headRemove);
    }
}

/**
 * 1 -> 2 -> 3 -> 4 -> 5 -> NULL
 * 5 -> 4 -> 3 -> 2 -> 1 -> NULL
 */
```

### 引入虚拟头结点后，算法就简化多了

> 虚拟头节点，可以避免head为空的各种情况，代码逻辑可以大大简化  

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        // 虚拟头节点，可以避免head为空的各种情况，代码逻辑可以大大简化     
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;

        // 所有节点的操作都统一了
        ListNode curr = dummyHead;
        while (curr.next != null) {
            if (curr.next.val == val) {
                // 把current.next这个节点释放掉
                curr.next = curr.next.next;
            } else {
                // 没有找到符合的节点就继续向下找
                curr = curr.next;
            }
        }
        // 虚拟头结点后面的点才是真正的头结点
        return dummyHead.next;
    }
}
```
