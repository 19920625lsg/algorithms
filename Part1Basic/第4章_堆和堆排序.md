# 第4章 堆和堆排序

> [本章PPT](https://git.imooc.com/coding-71/coding-71/src/master/04-Heap/Chapter-4-watermarked.pdf)

## 本章主要内容

+ 堆排序
+ 堆和优先队列

## 什么是优先队列

+ 普通队列：先进先出；后进后出
+ 优先队列：出队顺序和入队顺序无关；和优先级有关

## Java中优先队列的实现类是PriorityQueue

> 参考博文 [采用PriorityQueue实现大小顶堆 解决topK问题](https://blog.csdn.net/hefenglian/article/details/81807527)

默认是最小堆，最大堆需要自己传入Comparator

+ 新元素比堆顶元素大，就删除堆顶元素加入新元素，那么就是最大堆
+ 如果新数比堆顶元素小，则删除堆顶元素加入新元素，那就是最小堆

核心是如下两个函数

+ `offer(元素)`:优先队列加入元素
+ `poll()`:优先队列弹出最值元素

### 选择最大的K个数

> 用PriorityQueue默认是自然顺序排序(设升序，顶部是最小值)，要选择最大的k个数，构造小顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素大，则删除堆顶元素，并添加这个新数到堆中,循环一遍数组，优先队列中剩下的k个数就是最大的k个数

```java
public class findTopK {

    //找出前k个最大数，采用小顶堆实现
    public static int[] findKMax(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(k);//队列默认自然顺序排列，小顶堆，不必重写compare

        for (int num : nums) {
            if (pq.size() < k) {
                pq.offer(num);
            } else if (pq.peek() < num) {//如果堆顶元素 < 新数，则删除堆顶，加入新数入堆
                pq.poll();
                pq.offer(num);
            }
        }

        int[] result = new int[k];
        for (int i = 0; i < k&&!pq.isEmpty(); i++) {
            result[i] = pq.poll();
        }
        return result;
    }

 public static void main(String[] args) {
        int[]arr=new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9};
        System.out.println(Arrays.toString(findKMax( arr,5)));
    }
}
/**
输出：[5, 6, 7, 8, 9]
*/
```

### 选择最小的k个数

> 要选择最小的K个数使用大顶堆，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素小，则删除堆顶元素，并添加这个新数到堆中

```java
public class findTopK {

    ////要找前k个最小数，则构建大顶堆，要重写compare方法
    public static int[] findKMin(int[] nums, int k) {

        PriorityQueue<Integer> pq =
                new PriorityQueue<>(k, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
        });

        for (int num : nums) {
            if (pq.size() < k) {
                pq.offer(num);
            } else if (pq.peek() > num) {//如果堆顶元素 > 新数，则删除堆顶，加入新数入堆
                pq.poll();
                pq.offer(num);
            }
        }

        int[] result = new int[k];
        for (int i = 0; i < k&&!pq.isEmpty(); i++) {
            result[i] = pq.poll();
        }
        return result;
    }

    public static void main(String[] args) {
        int[]arr=new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9};
        System.out.println(Arrays.toString(findKMin( arr,5)));
    }

}
/**
输出：[5, 4, 3, 2, 1]
*/
```


## 为什么使用优先队列？(优先队列的应用场景)

+ windows任务管理器中选择优先级最高的任务执行
+ 请求处理，优先处理重要人的请求
+ 从1000000个元素中选出前100名，抽象模型就是从N个元素中选出前M个元素
