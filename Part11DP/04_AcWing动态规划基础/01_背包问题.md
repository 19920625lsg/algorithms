# 01_背包问题
## 一、01背包和完全背包问题
### 01背包问题
> 有N件物品和一个容量为V的背包，第i件物品的体积是v[i]、价值是w[i]，**每种物品只可以使用一次**，求将哪些物品放入背包可以使得价值总和最大。这里的w是weight即权重的意思

这是最基础的背包问题，"01"就是指每种物品要么选要么不选，我们定义状态$f[i][j]$表示从前i件物品中选出容量为j的背包能获得的最大价值

> 状态定义，根据第i个物品选还是不选，分成两种情况
+ 选第i个物品，$f[i][j] = f[i - 1][j - v[i]] + w[i]$，即从剩余的i-1个物品中选取容量总和为j-v[i]的物品，其价值加上第i个物品的价值w[i]即为最大价值
+ 不选第i个物品，$f[i][j] = f[i - 1][j]$，即从剩余的i-1个物品中选取容量总和为j的物品，其价值即为最大价值

取两者的较大值即为最终的最大价值$f[i][j] = max(f[i - 1][j - v[i]] + w[i], f[i - 1][j])$

> 上面求f[i][j]的时空复杂度都是$O(NV)$，这是优点高的，如何优化呢？

注意到每次我们都是从$f[i - 1]$递推到$f[i]$，可以只用O(V)的空间存下一步的f吗？即下一轮的i覆盖上一轮的i，i这一维度只保留长度为1即可，进一步可以直接把第一层去掉，只用j这个第二维度，伪代码如下：
```java
for(int i = 1; i <= N; i++) {
    for(int j = V; j >= v[i]; j--) { // 这里的V为什么是从大到小呢？下面会讲解地
        f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
    }
}
```
这里的V为什么是从大到小呢？因为这样每次计算f[j]的时候，f[V...j+1]已经是新的一轮的值了，而$f[j]$和$f[j - v[i]]$(分别压缩前的`f[i - 1][j]`和`f[i - 1][j - v[i]]`)肯定还没被更新，即为上一轮的值，用上一轮的值更新本轮的值，这样才符合动态规划的套路.

如果V从小到大，那么$f[j]$和$f[j - v[i]]$就会在计算f[j]之前被更新了，这样会导致不能用上一轮的值更新本轮的值，显然不符合动态规划的套路。

> 初始化时的一些要求：

初始化时$f[0] = 0; f[1...V] = -∞$，-∞一般用-INF且`INF = 0x3f3f3f3f; // 在Java中，注意这里的无穷大不要用系统自带的Integer.MIN_VALUE 或者 Integer.MAX_VALUE`
如果要求背包装满，答案就是$f[V]$，如果可以不装满，答案就是$max(f[1...V])$

### 完全背包问题
> 有N件物品和一个容量为V的背包，第i件物品的体积是v[i]、价值是w[i]，**每种物品都可以无限次使用**，求将哪些物品放入背包可以使得价值总和最大

> 状态定义:

假设第i个物品被选择了k次，易知k的范围为 $0 ≤ k * v[i] ≤ j$，相对于背包的选或不选，这里需要for循环不断更新选择的次数k，因此，动态规划的状态表达式就变成了

$f[i][j] = max(f[i - 1][j - k * v[i]] + k * w[i]  |  0 ≤ k * v[i] ≤ j)$ 含义是第i个物品选k次，从剩余的i-1个物品中选取物品来满足容量$j - k * v[i]$的限制

> 时间复杂度为$O(NV * ∑(V/v[i]))$，已经是相当大了，类比下01背包的二维降为一维的解法，看看能不能优化

实际只需要把01背包问题的V的倒向循环改成正向循环即可，代码如下：
```java
for(int i = 1; i <=n; i++) {
    for(int j = v[i]; j <= V; j++) { // 这里的V为什么是从小到大呢？下面会讲解地
        f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
    }
}
```
V为什么是从小到大呢？因为每次算f[j]的时候，f[j - v[i]]表示地是用前i个物品(可能已经拿过第i个物品了)凑出体积为`j - v[i]`的最大价值，此时不仅空间复杂度变成了$O(V)$，时间复杂度也变成了$O(NV)$

### 01背包和完全背包问题对比
![01背包与完全背包的对比](../01_万门大学邓哲也/01背包与完全背包的对比.png)