# 02 线性DP
## 一、数字三角形问题
> 题目链接：https://www.acwing.com/problem/content/900/

### 闫氏DP分析法过程
> 行列划分如下，绿色代表行，用i表示；红色代表列，用j表示

![三角问题](images/三角问题.png)

+ 状态表示：f[i][j]，表示走到第i行第j列的最大数字和
  + 集合：所有从起点，走到位置(i, j)的路径
  + 属性：max(即求上面集合中所有路径和的最大值)

+ 状态计算：
  + f[i][j]的可能的情况：
    + 从左上角过来：即从起点走到8的最大数字和 + 7，即$f[i - 1][j - 1] + a[i][j]$ 
    + 从右上角过来：即从起点走到1的最大数字和 + 7，即$f[i - 1][j] + a[i][j]$ 
  + 求属性：取上面两种情况的max，即$f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j])$


> 返回值：返回最后一行中的最大$f[i][j]$即可

### 代码实现

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int INF = 0x3f3f3f3f;
        // 因为后面的下标有i-1和j-1的情况，所以这里下标从1开始
        int[][] a= new int[n + 1][n + 1];
        int[][] f = new int[n + 1][n + 1]; // 必须初始化为负无穷大，因为数字可能会有负数
        for(int i = 0; i <= n; i++) {
            Arrays.fill(f[i], -INF);
        }
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= i; j++) {
                a[i][j] = sc.nextInt();
            }
        }
        
        f[1][1] = a[1][1]; // 第一个点到第一个点的最大数字和肯定是自己
        for(int i = 2; i <= n; i++) {
            for(int j = 1; j <= i; j++) {
                // 比较左上角和右下角的点那个更大
                f[i][j] = Math.max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j];
            }
        }
        
        // 遍历最后一行，找到最大的数字和
        int res = 0;
        for(int j = 1; j <= n; j++) res = Math.max(res, f[n][j]);
        System.out.println(res);
    }
}
```

## 最长上升子序列
> 题目链接：https://www.acwing.com/problem/content/897/
### 闫氏DP分析法过程
+ 状态表示：`f[i]`，以第i个数作为结尾的上升子序列
  + 集合：所有以第i个数作为结尾的上升子序列`1到i之间的元素`
  + 属性：max(所有以第i个数作为结尾的上升子序列中最长的长度)

+ 状态计算：
  + f[i]的可能的情况：从前面哪一种情况f[j]可以转化到f[i]，且$f[j]>f[i]$，此时$f[i] = f[j] + 1$，遍历所有情况不断更新最大的f[i]即可
    + i = 0，即前面没有数了
    + i = 1，即前面只有一个数
    + i = 2，前面有两个数
    + ....
    + i = i，前面一个数是i-1
  + 求属性：取上面两种情况的max，即$f[i] = max(f[j - 1] + 1 | 0 ≤ j ＜ i 并且 a[j] < a[i])$

> 返回值：返回最后一行中的最大$f[i][j]$即可

### 朴素代码实现如下：
```java
import java.util.*;

public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] a = new int[N + 1];
        for(int i = 1; i <= N; i++) a[i] = sc.nextInt();
        
        int[] f = new int[N + 1]; // f[i]表示以a[i]作为结尾的最长上升子序列的长度
        for(int i = 1; i <= N; i++) {
            f[i] = 1; // 只有一个元素时，最长长度显然为1
            for(int j = 1; j < i; j++) {
                if(a[j] < a[i]) {
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
        }
        
        // 枚举下所有的f[i]，找最大长度
        int res = 0;
        for(int i = 1; i <= N; i++) res = Math.max(res, f[i]);
        System.out.println(res);
    }
}
```

### 基于单调栈的优化
```java
import java.util.*;

// 维护一个单调栈，新来的元素大于栈顶元素就加入进去，否则就用新元素替换掉栈中第一个大于等于新元素的值，这里用
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] a = new int[N + 1];
        int[] f = new int[N + 1]; // 这就是要维护的单调递增栈

        for (int i = 1; i <= N; i++) a[i] = sc.nextInt();

        int cnt = 1;
        f[1] = a[1]; // 先把第一个元素加进去
        for (int i = 2; i <= N; i++) {
            if (a[i] > f[cnt]) f[++cnt] = a[i]; // 新来的元素大于栈顶元素就加入进去
            else { // 否则就用新元素替换掉栈中第一个大于等于新元素的值，这里用二分法(单调递增栈中用二分法正好)
                int l = 1, r = cnt;
                while (l < r) {
                    int mid = l + r >> 1;
                    if (f[mid] >= a[i]) r = mid;
                    else l = mid + 1;
                }
                f[l] = a[i]; // 左边界就是第一个大于等于目标值的值，替换成a[i]即可
            }
        }
        System.out.println(cnt);
    }
}

/**
例 n: 7
arr : 3 1 2 1 8 5 6

f : 3

1 比 3 小
f : 1

2 比 1 大
f : 1 2

1 比 2 小
f : 1 2

8 比 2 大
f : 1 2 8

5 比 8 小
f : 1 2 5

6 比 5 大
f : 1 2 5 6

f中有效元素的长度就是最长递增子序列的长度
*/
  
```