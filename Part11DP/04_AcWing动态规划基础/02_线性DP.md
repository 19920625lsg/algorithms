# 02 线性DP
## 一、数字三角形问题
> 题目链接：https://www.acwing.com/problem/content/900/

### 闫氏DP分析法过程
> 行列划分如下，绿色代表行，用i表示；红色代表列，用j表示

![三角问题](images/三角问题.png)

+ 状态表示：f[i][j]，表示走到第i行第j列的最大数字和
  + 集合：所有从起点，走到位置(i, j)的路径
  + 属性：max(即求上面集合中所有路径和的最大值)

+ 状态计算：
  + f[i][j]的可能的情况：
    + 从左上角过来：即从起点走到8的最大数字和 + 7，即$f[i - 1][j - 1] + a[i][j]$ 
    + 从右上角过来：即从起点走到1的最大数字和 + 7，即$f[i - 1][j] + a[i][j]$ 
  + 求属性：取上面两种情况的max，即$f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j])$


> 返回值：返回最后一行中的最大$f[i][j]$即可

### 代码实现

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int INF = 0x3f3f3f3f;
        // 因为后面的下标有i-1和j-1的情况，所以这里下标从1开始
        int[][] a= new int[n + 1][n + 1];
        int[][] f = new int[n + 1][n + 1]; // 必须初始化为负无穷大，因为数字可能会有负数
        for(int i = 0; i <= n; i++) {
            Arrays.fill(f[i], -INF);
        }
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= i; j++) {
                a[i][j] = sc.nextInt();
            }
        }
        
        f[1][1] = a[1][1]; // 第一个点到第一个点的最大数字和肯定是自己
        for(int i = 2; i <= n; i++) {
            for(int j = 1; j <= i; j++) {
                // 比较左上角和右下角的点那个更大
                f[i][j] = Math.max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j];
            }
        }
        
        // 遍历最后一行，找到最大的数字和
        int res = 0;
        for(int j = 1; j <= n; j++) res = Math.max(res, f[n][j]);
        System.out.println(res);
    }
}
```