# 第03章_线性模型与区间DP
## 3.1 第03章_线性模型
### 基本概念
+ 这里的线性是指**状态的排布**是线性的
+ 线性模型是动态规划中最常用的模型

一般的代码模型是：
```java
for(int i = 0; i < n; i++) {
    for(j = 0; j < i; j++) {
        // Todo: 更新dp的具体逻辑
    }
}
```

### 最典型的一个例题：最长上升子序列
> 见[第02章_动态规划简介.md#举例2从n个数的数组a中找出最长上升子序列的元素个数](第02章_动态规划简介.md#举例2从n个数的数组an中找出最长上升子序列的元素个数)

### 另一个例题：[POJ3486 买电脑](https://ac.nowcoder.com/acm/problem/108083)
> 参考讲解：https://www.cnblogs.com/LYFer233/p/12884322.html

假设上一次买电脑是第j年，那么`1~j-1`年就是一个子问题，我们已经算出了`dp[j-1]`是满足这个问题的最优解，后面我们就不用考虑前`j-1`年的情况，且他们也不会影响我们后面的决策，即满足`最优子问题`和`无后效性原则`，所以可以用动态规划来做
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        while (s.hasNext()) { // 注意多个用例的情况
            int c = s.nextInt(); // 买一台新电脑需要的花费
            int n = s.nextInt(); // 需要拥有电脑的年数
            int[][] m = new int[n + 1][n + 1]; // 下标从1开始
            for (int i = 1; i <= n; i++) {
                for (int j = i; j <= n; j++) m[i][j] = s.nextInt();
            }
            int[] dp = new int[n + 1];
            Arrays.fill(dp, Integer.MAX_VALUE); // 求每年的最小花费，需要先初始化为最大值
            dp[0] = 0; // 没电脑时就没花费
            for (int i = 1; i <= n; i++) {
                // 假设上一次买电脑是第j年
                for (int j = 1; j <= i; j++) {
                    // dp[j - 1]表示截止在j-1年买电脑产生的所有花费，m[j][i]表示上第j年到第i年产生的维修费用，c表示此次买电脑的费用
                    dp[i] = Math.min(dp[i], dp[j - 1] + m[j][i] + c); // 找到在第j-1年更新电脑所需的最小花费(遍历所有的j)，维修费用从买电脑的第2年才开始交，所以是(j - 1)+ 1 = j
                }
            }
            System.out.println(dp[n]);
        }
    }
}
```

## 3.2 区间DP
## 3.3~3.6 知识精练