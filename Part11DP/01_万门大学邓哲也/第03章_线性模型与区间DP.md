# 第03章_线性模型与区间DP
## 3.1 第03章_线性模型
### 基本概念
+ 这里的线性是指**状态的排布**是线性的
+ 线性模型是动态规划中最常用的模型

一般的代码模型是：
```java
for(int i = 0; i < n; i++) {
    for(j = 0; j < i; j++) {
        // Todo: 更新dp的具体逻辑
    }
}
```

### 最典型的一个例题：最长上升子序列
> 见[第02章_动态规划简介.md#举例2从n个数的数组a中找出最长上升子序列的元素个数](第02章_动态规划简介.md#举例2从n个数的数组an中找出最长上升子序列的元素个数)

### 另一个例题：[POJ3486 买电脑](https://ac.nowcoder.com/acm/problem/108083)
> 参考讲解：https://www.cnblogs.com/LYFer233/p/12884322.html

假设上一次买电脑是第j年，那么`1~j-1`年就是一个子问题，我们已经算出了`dp[j-1]`是满足这个问题的最优解，后面我们就不用考虑前`j-1`年的情况，且他们也不会影响我们后面的决策，即满足`最优子问题`和`无后效性原则`，所以可以用动态规划来做
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        while (s.hasNext()) { // 注意多个用例的情况
            int c = s.nextInt(); // 买一台新电脑需要的花费
            int n = s.nextInt(); // 需要拥有电脑的年数
            int[][] m = new int[n + 1][n + 1]; // 下标从1开始
            for (int i = 1; i <= n; i++) {
                for (int j = i; j <= n; j++) m[i][j] = s.nextInt();
            }
            int[] dp = new int[n + 1];
            Arrays.fill(dp, Integer.MAX_VALUE); // 求每年的最小花费，需要先初始化为最大值
            dp[0] = 0; // 没电脑时就没花费
            for (int i = 1; i <= n; i++) {
                // 假设上一次买电脑是第j年
                for (int j = 1; j <= i; j++) {
                    // dp[j - 1]表示截止在j-1年买电脑产生的所有花费，m[j][i]表示上第j年到第i年产生的维修费用，c表示此次买电脑的费用
                    dp[i] = Math.min(dp[i], dp[j - 1] + m[j][i] + c); // 找到在第j-1年更新电脑所需的最小花费(遍历所有的j)，维修费用从买电脑的第2年才开始交，所以是(j - 1)+ 1 = j
                }
            }
            System.out.println(dp[n]);
        }
    }
}
```

## 3.2 区间DP
### 基本概念
区间DP，顾名思义，就是在区间上的DP

一般是先算出小区间的DP得到最优解，再去得到大区间的最优解

一般的状态是假设`dp[i][j]`是区间`[i, j]`的最优解，那么`dp[i][j]`都可以由`[i, j]`的自区间的最优解更新得到


### 例题1：[合并果子](https://www.acwing.com/problem/content/150/)
用dp[i][j]来表示合并[i, j]即第i堆到第j对果子合并产生的最小代价

思考转移：因为合并之后[i, j]的所有堆果子就成了一堆，因此合并之前一定是两堆，我们可以**枚举分界线**，也就是枚举$i≤k≤j$，此时假设合并前的两堆分别是$[i, k]$和$[k + 1, j]$

这两堆本身就花费了$dp[i][k] + dp[k + 1][j]$的代价。而合并这两堆过程中新花费的代码与k没有关系，因为就是$a[i] + a[i + 1] + a[i + 2] + ...... + a[j]$，用前缀和s表示就是$s[j] - s[l - 1]$

因此我们得到动态规划的状态转移公式是：$dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + s[j] - s[i - 1])$

> 递归实现，会超时
```java
import java.util.*;

public class Main {
    private static int n;
    private static int[] a;
    private static int[] s;
    private static int[][] dp;

    public static int cal(int i, int j) {
        if (i == j) return 0; // 只有一堆的时候，代价为0，不需要合并或者也可以认为合并代价为0
        if (dp[i][j] != Integer.MAX_VALUE) return dp[i][j]; // 前面计算过地话直接返回
        for (int k = i; k < j; k++) {
            dp[i][j] = Math.min(dp[i][j], cal(i, k) + cal(k + 1, j) + s[j] - s[i - 1]);
        }
        return dp[i][j];
    }

    public static void main(String[] args) {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(b.readLine());
        a = new int[n + 1];
        s = new int[n + 1]; // 前缀和数组
        dp = new int[n + 1][n + 1];
        String[] nums = b.readLine().split(" ");
        for (int i = 1; i <= n; i++) {
            a[i] = Integer.parseInt(nums[i - 1]); // 读取各类果子的数目
            s[i] = s[i - 1] + a[i];
            Arrays.fill(dp[i], Integer.MAX_VALUE); // 求最小代价，那么就要初始化为最大值
        }

        // 记忆化递归
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j++) cal(i, j); // 计算区间[i, j]合并的最小代价
        }
        System.out.println(dp[1][n]);
    }
}
```

> 动态规划实现

```java
import java.util.*;
import java.io.*;

public class Main {
    private static int n;
    private static int[] a;
    private static int[] s;
    private static int[][] dp;

    // 直接dp，要先计算小区间的答案
    public static int cal() {
        for (int i = 1; i <= n; i++) dp[i][i] = 0; // 区间长度为1，即只有一堆，不需要额外费体力
        for (int len = 2; len <= n; len++) { // 闭区间的区间长度
            for (int i = 1; i + len - 1 <= n; i++) { // 注意是闭区间，所以计算区间长度需要减1
                int j = i + len - 1;
                for (int k = i; k < j; k++) {
                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + s[j] - s[i - 1]);
                }
            }
        }
        return dp[1][n];
    }

    public static void main(String[] args) throws IOException {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(b.readLine().trim());
        a = new int[n + 1];
        s = new int[n + 1]; // 前缀和数组
        dp = new int[n + 1][n + 1];
        String[] nums = b.readLine().split(" ");
        for (int i = 1; i <= n; i++) {
            a[i] = Integer.parseInt(nums[i - 1]); // 读取各类果子的数目
            s[i] = s[i - 1] + a[i];
            Arrays.fill(dp[i], Integer.MAX_VALUE); // 求最小代价，那么就要初始化为最大值
        }
        // 动态规划计算
        System.out.println(cal());
    }
}
```

### 例题2：[最长括号匹配](https://www.luogu.com.cn/problem/P1944)


## 3.3~3.6 知识精练