# 第04章_背包问题
## 4.1 01背包和完全背包问题
### 01背包问题
> 有N件物品和一个容量为V的背包，第i件物品的体积是v[i]、价值是w[i]，**每种物品只可以使用一次**，求将哪些物品放入背包可以使得价值总和最大。这里的w是weight即权重的意思

这是最基础的背包问题，"01"就是指每种物品要么选要么不选，我们定义状态$f[i][j]$表示从前i件物品中选出容量为j的背包能获得的最大价值

> 状态定义，根据第i个物品选还是不选，分成两种情况
+ 选第i个物品，$f[i][j] = f[i - 1][j - v[i]] + w[i]$，即从剩余的i-1个物品中选取容量总和为j-v[i]的物品，其价值加上第i个物品的价值w[i]即为最大价值
+ 不选第i个物品，$f[i][j] = f[i - 1][j]$，即从剩余的i-1个物品中选取容量总和为j的物品，其价值即为最大价值

取两者的较大值即为最终的最大价值$f[i][j] = max(f[i - 1][j - v[i]] + w[i], f[i - 1][j])$

> 上面求f[i][j]的时空复杂度都是$O(NV)$，这是优点高的，如何优化呢？

注意到每次我们都是从$f[i - 1]$递推到$f[i]$，可以只用O(V)的空间存下一步的f吗？即下一轮的i覆盖上一轮的i，i这一维度只保留长度为1即可，进一步可以直接把第一层去掉，只用j这个第二维度，伪代码如下：
```java
for(int i = 1; i <= N; i++) {
    for(int j = V; j >= v[i]; j--) { // 这里的V为什么是从大到小呢？下面会讲解地
        f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
    }
}
```
这里的V为什么是从大到小呢？因为这样每次计算f[j]的时候，f[V...j+1]已经是新的一轮的值了，而$f[j]$和$f[j - v[i]]$(分别压缩前的`f[i - 1][j]`和`f[i - 1][j - v[i]]`)肯定还没被更新，即为上一轮的值，用上一轮的值更新本轮的值，这样才符合动态规划的套路.

如果V从小到大，那么$f[j]$和$f[j - v[i]]$就会在计算f[j]之前被更新了，这样会导致不能用上一轮的值更新本轮的值，显然不符合动态规划的套路。

> 初始化时的一些要求：

初始化时$f[0] = 0; f[1...V] = -∞$，-∞一般用-INF且`INF = 0x3f3f3f3f; // 在Java中，注意这里的无穷大不要用系统自带的Integer.MIN_VALUE 或者 Integer.MAX_VALUE`
如果要求背包装满，答案就是$f[V]$，如果可以不装满，答案就是$max(f[1...V])$

### 完全背包问题
> 有N件物品和一个容量为V的背包，第i件物品的体积是v[i]、价值是w[i]，**每种物品都可以无限次使用**，求将哪些物品放入背包可以使得价值总和最大

> 状态定义:

假设第i个物品被选择了k次，易知k的范围为 $0 ≤ k * v[i] ≤ j$，相对于背包的选或不选，这里需要for循环不断更新选择的次数k，因此，动态规划的状态表达式就变成了

$f[i][j] = max(f[i - 1][j - k * v[i]] + k * w[i]  |  0 ≤ k * v[i] ≤ j)$ 含义是第i个物品选k次，从剩余的i-1个物品中选取物品来满足容量$j - k * v[i]$的限制

> 时间复杂度为$O(NV * ∑(V/v[i]))$，已经是相当大了，类比下01背包的二维降为一维的解法，看看能不能优化

实际只需要把01背包问题的V的倒向循环改成正向循环即可，代码如下：
```java
for(int i = 1; i <=n; i++) {
    for(int j = v[i]; j <= V; j++) { // 这里的V为什么是从小到大呢？下面会讲解地
        f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
    }
}
```
V为什么是从小到大呢？因为每次算f[j]的时候，f[j - v[i]]表示地是用前i个物品(可能已经拿过第i个物品了)凑出体积为`j - v[i]`的最大价值，此时不仅空间复杂度变成了$O(V)$，时间复杂度也变成了$O(NV)$

### 01背包和完全背包问题对比
![01背包与完全背包的对比](01背包与完全背包的对比.png)

## 4.2 多重背包问题二进制拆分优化
### 多重背包问题
> 有N件物品和一个容量为V的背包，第i件物品的体积是v[i]、价值是w[i]，**每种物品只可以使用a[i]次**，求将哪些物品放入背包可以使得价值总和最大

**多重背包**问题和**01背包**问题、**完全背包**问题的不同之处在于指定了第i个物品的使用次数，即每个物品的使用次数都可能是不同的

> 状态分析

$f[i][j] = max(f[i - 1][j - k * v[i]] + k * w[i]  |  0 ≤ k * v[i] ≤ a[i])$

> 时间复杂度为$O(NV * ∑(a[i]))$了，需要优化

### 多重背包问题二进制拆分优化
拿上面的题的具体化举例，比如一个物品最多有15个可用，15的二进制是1111，那么可以把这个物品拆成4份，分别代表8个物品、4个物品、2个物品、1个物品，此时**不管选出0~15中的任何数量个，都可以由这4份组合出来(`二进制的理解`)**

这样上面的4份，每份要么选要么不选，显然成了一个新的01背包问题~用01背包的思路解决问题接口~重复`log a[i]`次01背包问题即可

但是上面的15正好可以拆分各位都是1的二进制，如果问题改成一个物品最多有12个可用，12的二进制是1100，按照上面的思路可以拆成1100，即8个和4个，这两个数并不能组成1~12之间所有的数

因此对于任何a[i]，我们都先拆成1个、2个、4个、...、$2^k$个、$a[i] - 2^k$ 个，k是满足$2^k-1 < n$的最大值。这种拆分就可以拼出0~a[i]内的任何值了(即多重背包选择i的个数)。比如12就可以拆分成1、2、4、5

通过上面的二进制拆分，对于一个最大可用数为a[i]的物品来说，我们就把它拆分了$log(a[i])$个只能用一次的物品，体积为$kv[i]$，价值为$kw[i]$，这样问题就变成了01背包问题，只是物品数量变成了$\sum_{i=1}^{N}log(a[i])$个，时间复杂度是O($V\sum_{i=1}^{N}log(a[i])$)
## 4.3 多重背包问题单调队列优化
> 上一节得到的多重背包问题的公式为：$f[i][j] = max(f[i - 1][j - k * v[i]] + k * w[i]  |  0 ≤ k * v[i] ≤ a[i])$，含义是第i个物品选k次，从剩余的i-1个物品中选取物品来满足容量$j - k * v[i]$的限制。遍历k的所有取值来找价值是多少
### 利用模和取余进行状态表达式简化
对于f[i][j]（`从i个物品中选取物品填满容量为j的容器，其最大价值是f[i][j]`）。k的范围受两个因素影响，一是a[i]表示k的上限，此外还要$ j - k * v[i] > 0$即$k < j / v[i]$，所以k的上限为两者的较小值，我们设物品个数为i时k的范围为b[i]，那么$b[i] = min(a[i], j / v[i])$

此时状态表达式变为：$$f[i][j] = max(f[i - 1][j - k * v[i]] + k * w[i] | 0 ≤ k ≤ b[i])$$

下面观察f[i][j]会从哪些状态转移过来：

对于$${ j - k * v[i] | 0 ≤ k ≤ b[i] }$$，$j - k * v[i]$模v[i]的余数都是相等的(因为k取不同的值结果都是差v[i]的整数倍)

我们令余数$mod = j % v[i]$，除数$div = j / v[i]$，那么j可以表示为$j = div * v[i] + mod$，替换f[i][j]里面的j可以得到$$f[i][j] = max(f[i - 1][div * v[i] + mod - k * v[i]] + k * w[i] | 0 ≤ k ≤ b[i])$$ $$= max(f[i - 1][mod +  (div - k) * v[i]] + k * w[i] | 0 ≤ k ≤ b[i])$$

我们假设$k' = div - k$，因为 $0 ≤ k ≤ b[i]$，即$0 ≤ (div - k') ≤ b[i]$，移项可得$k'$的范围是$(div - b[i]) ≤  k' ≤ div$，k'带入上面的式子，可以得到$$f[i][j] = max(f[i - 1][mod + k' * v[i]] + (div - k') * w[i] | div - b[i] ≤  k' ≤ div)$$

把div * w[i] 单独拿出来，得到 $$f[i][j] = max(f[i - 1][mod + k' * v[i]] - k' * w[i] | (div - b[i]) ≤  k' ≤ div) + div * w[i]$$，这里k'批量换成k（就是个符号表示，和原来的k不是一个k），得到$$f[i][j] = max(f[i - 1][mod + k * v[i]] - k * w[i] | (div - b[i]) ≤  k ≤ div) + div * w[i]$$

考虑{mod, mod + v[i], mod + 2* v[i] + mod + 3 * v[i], ..., j}，可以知道f[i][j]就是求j前面的$b[i]+1$(`为什么是b[i] + 1？因为b[i]是V/v[i]和a[i]的较小值，是真实的第i个物品选取个数的上限`)个数对应的$f[i - 1][mod + k' * v[i]] - k' * w[i]$的最大值

对于最外层i的枚举，b[i]+ 1是固定的，因此问题转化为**求一个固定长度的滑窗内的最大值**，显然可以用单调队列来优化。

我们可以维护一个单调下降的队列，每次加入的时候加入到队尾，保证队头到队尾单调递减。每次弹出队头，直到满足队头在滑窗内，队头的值就是这个滑窗内的最大值，这样这一步就是线性的。

我们枚举mod，再枚举div，求f[i][j]是用单调队列，总共是O(V)的，总的时间复杂度仍然保持在了O(NV)

## 4.4~4.7 知识精练
### [CodeForces 366C Dima And Salad](https://www.luogu.com.cn/problem/CF366C)
> 有n个数对(a[i], b[i])，现在要求去除若干个数对使得$sum(a[i]) / sum(b[i]) = k$，你需要最大化sum(a[i])，其中 $n ≤ 100, k ≤ 10, a[i] ≤ 100$

比如下面的输入表示输入3(`n的值`)个数对，$sum(a[i]) / sum(b[i]) = 2 = k$，a[1]~a[3]为`10 8 1`，b[1]~b[3]为`2 7 1`
```txt
3 2
10 8 1
2 7 1
```
输出为
```txt
18
```
因为$(a[1] + a[2])/(b[1] + b[2]) = (10 + 8) / (2 + 7) = 2 = k$，$sum(a[i]) = 10 + 8 = 18$

再如下面的输入：
```txt
5 3 // 一共5对数，sum(a[i]) / sum(b[i]) = 3
4 4 4 4 4
2 2 2 2 2
```
输出为：
```txt
-1
```
因为上面的$sum(a[i])/sum(b[i])$显然只能为2，不可能出现3

> 题目转换

观察$sum(a[i]) / sum(b[i]) = k$，移项可得$sum(a[i]) = sum(b[i]) * k$，再移项可得$sum(a[i]) - sum(b[i]) * k = 0$，合并下可以得到$sum(a[i] - k * b[i]) = 0$

至此，问题也就转换成了第i个物体的体积是$v[i] = a[i] - k * b[i]$，价值是a[i]，的背包问题，为了防止总的体积被v[i]减成负的(`j-v[i]`要大于0)，所以初始化时j要足够大，我们取10000，这样我们就可以分成正负两个f来做了

本问题即是求1~i对应的a和b放入后$\sum_{i=1}^{i}v[i]$是0，且$sum(a[i])=\sum_{i=1}^{i}a[i]$`即放入的所有的物体i的价值和`最大)

> 最终的代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5 + 10;
int a[N], b[N], n, k;
int f1[N], f2[N];
int v[N];

int main() {
    scanf("%d %d", &n, &k);
    memset(f1, -INF, sizeof(f1)); // 要求最大值，先要初始化最小值
    memset(f2, -INF, sizeof(f2));
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    f1[0] = f2[0] = 0;
    for (int i = 1; i <= n; i++) {
        v[i] = a[i] - k * b[i];
        if (v[i] >= 0) {
            // j初始化10000因为要保证 j≥v[i]的条件不成立前i要能循环完，因此j要足够大
            for (int j = 10000; j >= v[i]; j--) f1[j] = max(f1[j], f1[j - v[i]] + a[i]);
        } else {
            // 处理v[i]小于0的情况
            v[i] = -v[i];
            for (int j = 10000; j >= v[i]; j--) f2[j] = max(f2[j], f2[j - v[i]] + a[i]);
        }
    }
    int res = -1;
    for (int i = 0; i <= 10000; i++) {
        if (f1[i] == 0 && f2[i] == 0) continue;
        res = max(res, f1[i] + f2[i]);
    }
    printf("%d\n", res);
}
```
> java实现如下
```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        int k = s.nextInt();
        int[] a = new int[n + 1];
        int[] b = new int[n + 1];
        for (int i = 1; i <= n; i++) a[i] = s.nextInt();
        for (int i = 1; i <= n; i++) b[i] = s.nextInt();
        int N = 10000, INF = 0x3f3f3f3f; // 这里的无穷大不要用系统自带的Integer.MIN_VALUE
        int[] f1 = new int[N + 1];
        int[] f2 = new int[N + 1];
        Arrays.fill(f1, -INF);
        Arrays.fill(f2, -INF);
        f1[0] = 0;
        f2[0] = 0;
        int[] c = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            v[i] = a[i] - k * b[i];
            if (v[i] >= 0) {
                // j初始化10000因为要保证 j≥v[i]的条件不成立前i要能循环完，因此j要足够大
                for (int j = N; j >= v[i]; j--) f1[j] = Math.max(f1[j], f1[j - v[i]] + a[i]);
            } else {
                // 处理v[i]小于0的情况
                v[i] = -v[i];
                for (int j = N; j >= v[i]; j--) f2[j] = Math.max(f2[j], f2[j - v[i]] + a[i]);
            }
        }
        int res = -1;
        for (int i = 0; i <= N; i++) {
            if (f1[i] == 0 && f2[i] == 0) continue;
            res = Math.max(res, f1[i] + f2[i]);
        }
        System.out.println(res);
    }
}
```

### [CF864E Fire](https://www.luogu.com.cn/problem/CF864E)
> 题目分析

是个典型的01背包问题，这里的花费不是体积，而是时间。用f[i]表示到i时刻最大能救多少价值，j表示第j个物品救还是不救

$f[i] = max(f[i], f[i - t[j]] + p[j])$ 其中 $(i - t[j]) ≤ d[j]$否则第j个物品就开始燃烧而没法抢救了

因此先对物品按照d[i]进行排序，然后依次更新，即按照然后开始的时刻早晚依次开始抢救

> 代码如下：参考地 https://www.luogu.com.cn/blog/213870/solution-cf864e

这道题很明显是一个01背包。

第一问：先将所有数据存在结构体里，按 d[i] 排序，然后当成普通01背包做，在第二层循环时边界调整为 d[i] 即可。

转移方程： $f[i]=max(f[i], f[i - t[i]] + p[i])$

对于第二问，每一个 f[i] 都有一个对应的数组储存最优解下取的物品。

注意：第 i 件物品在 d[i] 秒彻底焚毁，所以第二层循环只能循环到 $d[i] − 1$ 。

代码：

```cpp
#include<bits/stdc++.h>

using namespace std;
struct Item { //结构体，p,t,d作用于题面里相同，num储存编号
    int p, t, d, num;
} a[110];
int n, f[2010], ans, ansnum; //ans储存最大价值，ansnum储存最大价值对应的f[i]的编号
vector<int> v[2010];

bool cmp(Item i1, Item i2) {
    return i1.d < i2.d; //按d排序
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].t >> a[i].d >> a[i].p;
        a[i].num = i;
    }
    sort(a + 1, a + n + 1, cmp);
    for (int i = 1; i <= n; i++)
        for (int j = a[i].d - 1; j >= a[i].t; j--) // 只能取一次，倒序循环（从a[i].d-1开始！）
            if (f[j - a[i].t] + a[i].p > f[j]) {
                f[j] = f[j - a[i].t] + a[i].p; // 转移方程
                v[j] = v[j - a[i].t];
                v[j].push_back(a[i].num); // 更新v[j]
            }
    for (int i = 0; i <= 2000; i++) {
        if (f[i] > ans) {
            ans = f[i];
            ansnum = i;
        }
    }
    cout << ans << endl << v[ansnum].size() << endl;
    for (int i : v[ansnum]) cout << i << " ";//输出
    return 0;
}
```

### [POJ1742 Coins](https://ac.nowcoder.com/acm/problem/106339)
> 题意：有n种面额的硬币。面额、个数分别为A_i、C_i，求最多能搭配出几种不超过m的金额？

思路：f[j]就是总数为j的价值是否已经有了i可以满足这种方法，如果现在没有，那么我们就一个个硬币去尝试直到有，这种价值方法有了的话，那么就是总方法数加1。多重背包可行性问题

```cpp
#include <cstdio>
#include <cstring>

using namespace std;

int f[100005]; //表示当前i价格是否出现过
int sum[100005];//当价格达到i时，最多使用这一种硬币的次数
int v[105], v[105];

int main() {
    int i, j, n, m;
    while (~scanf("%d%d", &n, &m), n + m) {
        for (i = 1; i <= n; i++) scanf("%d", &v[i]);
        for (i = 1; i <= n; i++) scanf("%d", &v[i]);
        memset(f, 0, sizeof(f));
        f[0] = 1;
        int ans = 0;
        for (i = 1; i <= n; i++) {
            memset(sum, 0, sizeof(sum));// 关键是用sum来限定了次数
            for (j = v[i]; j <= m; j++) { // 循环检查看是否能够出现前边没有出现的价格
                if (!f[j] && f[j - v[i]] && sum[j - v[i]] < v[i]) { // 如果j价格没有出现过，且j-v[i]出现过，并且使用i硬币的次数没有超出给定的数量
                    f[j] = 1;
                    sum[j] = sum[j - v[i]] + 1;// 使用次数+1
                    ans++;
                }
            }
        }
        printf("%d\n", ans);
    }

    return 0;
}
```

### [F755F PolandBall And Gifts](https://www.luogu.com.cn/problem/CF755F)
> 题解：https://www.luogu.com.cn/problem/solution/CF755F

```cpp
#include<cstdio>
#include<iostream>
#include<queue>

using namespace std;
const int Maxn = 1000010, inf = 0x3f3f3f3f;
int e[Maxn], f[Maxn], v[Maxn], a[Maxn];
int bin[Maxn];
bool vis[Maxn];
int n, m, ans, tot;

inline int read() {
    int s = 0, w = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-')w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
    return s * w;
}

void bfs(int s) {
    queue<int> q;
    q.push(s);
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        f[x] = s, v[s]++;
        int y = e[x];
        if (!f[y])q.push(y);
    }
}

int main() {
    //freopen("in.txt","r",stdin);
    n = read(), m = read();
    for (int i = 1; i <= n; ++i)
        e[i] = read();
    for (int i = 1; i <= n; ++i)
        if (!f[i]) {
            bfs(i);
            bin[v[i]]++;
            ans += (v[i] >> 1);//注意一定要在二进制分组之前统计，不然就不能达到在奇环的时候的向下取整的效果了
        }
    for (int i = 1; i <= n; ++i) {
        if (!bin[i])continue;
        for (int j = 1; bin[i] >= j; j <<= 1)
            a[++tot] = j * i, bin[i] -= j;
        if (bin[i])a[++tot] = bin[i] * i;
    }
    vis[0] = 1;
    for (int i = 1; i <= tot; ++i) {
        for (int j = m - a[i]; j >= 0; --j)
            if (vis[j])vis[j + a[i]] = 1;
    }
    if (vis[m])printf("%d ", m);
    else printf("%d ", m + 1);
    if (ans >= m)printf("%d\n", m << 1);
    else printf("%d\n", (ans << 1) + min(m - ans, n - (ans << 1))); //如果不够就找人去补
    //注意！最后收不到礼物的人数不能超过 n !!!
    return 0;
}
```

### [NOIP2014 Day1 飞扬的小鸟](https://www.luogu.com.cn/problem/P1941)
> 题解：https://www.luogu.com.cn/problem/solution/P1941