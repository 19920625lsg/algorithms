# 第06章 树状DP
> 树状动态规划
## 6.1 树状DP简介
### 基本介绍
状态图是一棵树，状态转移也发生在树上，父节点的值通过所有子节点的值得到，一般是在DFS过程中完成DP递推计算，伪代码如下：
```cpp
void dfs(u) {
    for v in u.child {
        dfs(v);
        use dp[v] to update dp[u]; // 递归回溯过程中更新
    }  
}
```
### 典例问题1 ：树上最长链
给定一棵树，每条边都有权，计算一条最长链，要求时间复杂度为O(n)

> 解决方案如下：

定义f[i]是以i为根的子树中的最长链。
+ 对于不经过i的路径：显然f[i] = max(f[i], f[j]) `j是i的子节点`
+ 对于经过i的路径，就需要选择两个子节点，把两个子节点往下走的最长路相加，再加上它们到i的路径和，去更新f[i]
  > 对于上面提到的最长路，定义g[i]表示从i往下走最远能走多远(即最长链)，$g[i] = max(g[i], g[j] + w(i, j))$ `其中j是i的子节点，为了获取g[j]需要进行DFS`，对于叶子节点f[i] = g[i] = 0

> 伪代码如下：

```cpp
void dfs(int u) {
    f[u] = g[u] = 0;
    int maxg1 = -1e9, maxg2 = -1e9;
    for(int v : u.children) { // v是u的子节点
        dfs(v); // 递归遍历子节点v，得到g[v]和f[v]，然后在下面的递归回溯过程中更新g[u]和f[u]
        g[u] = max(g[u], edge[u][v].weight + g[v]); // 根据u和v的权重加上dfs得到的g[v]来更新g[u]
        f[u] = max(f[u], f[v]); // 用子节点和当前节点的较长链来更新f[u]
        ...
        // 获取u的最长连长度排前二的两个子树
        if(g[v] + edge[u][v].weight > maxg1) {
            maxg2 = maxg1;
            maxg1 = g[v] + edge[u][v].weight;
        } else if(g[v] + edge[u][v].weight > maxg2) {
            maxg2 = g[v] + edge[u][v].weight;
        }
    }
    f[u] = max(f[u], maxg1 + maxg2);
}
```
我们从root开始进行DFS，最终的问题答案就是f[root]

### 典例问题1:`最大权值和`子树
给定一棵树，每个点都有权值(可正可负)。求一个子树，使得权值最大。要求时间复杂度为O(n)

设f[i]表示以i为根的子树中的最大权值和子树，为了方便转移，我们需要用新的一维表示是否选第i个点，f[i][1]表示选，f[i][0]表示不选
+ i选：$f[i][1] = w[i] + sum(max(0, f[j][1]) | j是i的子节点)$
+ i不选：$f[i][0] = max(0, max(max(f[j][0], f[j][1]) | j是i的子节点))$
  > i不选，其子树必然无法互相联通，因此只能遍历找到其所有子节点j所在子树的权值最大者

## 6.1~6.5 知识精练
### [HDU 1561 The more, The Better](http://acm.hdu.edu.cn/showproblem.php?pid=1561)
> 讲解：https://www.cnblogs.com/luyouqi233/p/8831338.html

简化题意为：在一棵树上有n个点，每个点有一定权值，找出一棵m个点的子树，使它的权值和最大(子树不一定是是连通的)。

很容易想到一个表示状态的方法：$f[i][j]$表示在根节点为i的子树中取j个点的最大权值和

如何从子节点的状态合并到父节点i呢？

假设i子树有k个子节点，每个子节点对应的子树分别有sz[1]、sz[2]、sz[3]......sz[k]个节点

相当于有k个盒子，第x个盒子中有sz[x]个节点，要从k个盒子中取出j个节点，用j个节点的权值和去更新$f[i][j]$，使得最终的权值和$f[i][j]$最大。

显然这个问题是个01背包问题，总体积是j，从$sz[1] + sz[2] + sz[3]......sz[k]$个中选取j个物品填满j的背包，每个物品的价值就是其权值，求使得最终的价值最大的选取方案

显然有`f[i][1] = w[i]`，以i为根节点的子树只选一个节点，显然只能选自己，最大权值显然也是自己了

然后枚举所有的i的子节点：**f[i][j] = max(max(f[i][j - k] + f[v][k]`1 ≤ k < j 遍历k`)`v是i的子节点，遍历v即可`)**

$f[i][j - k]$表示v以外的i的子节点选取j-k个子节点

时间复杂度分析：每次从子节点更新当前点的状态需要$O(n^2)$，总时间复杂度是$O(n^3)$

小优化：$f[i][j]$中j小于等于子树i中的节点总数

### [HDU 5593 ZYB's Tree](http://acm.hdu.edu.cn/showproblem.php?pid=5593)
### [POJ 2486 Apple Tree](http://poj.org/problem?id=2486)
### [HDU 3586 Information Disturbing](http://acm.hdu.edu.cn/showproblem.php?pid=3586)
### [CodeForces 960E Alternating Tree](https://www.luogu.com.cn/problem/CF960E)
