# 第06章 树状DP
> 树状动态规划
## 6.1 树状DP简介
### 基本介绍
状态图是一棵树，状态转移也发生在树上，父节点的值通过所有子节点的值得到，一般是在DFS过程中完成DP递推计算，伪代码如下：
```cpp
void dfs(u) {
    for v in u.child {
        dfs(v);
        use dp[v] to update dp[u]; // 递归回溯过程中更新
    }  
}
```
### 典例问题类型1 ：树上最长链
给定一棵树，每条边都有权，计算一条最长链，要求时间复杂度为O(n)

> 解决方案如下：

定义f[i]是以i为根的子树中的最长链。
+ 对于不经过i的路径：显然f[i] = max(f[i], f[j]) `j是i的子节点`
+ 对于经过i的路径，就需要选择两个子节点，把两个子节点往下走的最长路相加，再加上它们到i的路径和，去更新f[i]
  > 对于上面提到的最长路，定义g[i]表示从i往下走最远能走多远(即最长链)，$g[i] = max(g[i], g[j] + w(i, j))$ `其中j是i的子节点，为了获取g[j]需要进行DFS`，对于叶子节点f[i] = g[i] = 0

> 伪代码如下：

```cpp
void dfs(int u) {
    f[u] = g[u] = 0;
    int maxg1 = -1e9, maxg2 = -1e9;
    for(int v : u.children) { // v是u的子节点
        dfs(v); // 递归遍历子节点v，得到g[v]和f[v]，然后在下面的递归回溯过程中更新g[u]和f[u]
        g[u] = max(g[u], edge[u][v].weight + g[v]); // 根据u和v的权重加上dfs得到的g[v]来更新g[u]
        f[u] = max(f[u], f[v]); // 用子节点和当前节点的较长链来更新f[u]
        ...
        // 获取u的最长连长度排前二的两个子树
        if(g[v] + edge[u][v].weight > maxg1) {
            maxg2 = maxg1;
            maxg1 = g[v] + edge[u][v].weight;
        } else if(g[v] + edge[u][v].weight > maxg2) {
            maxg2 = g[v] + edge[u][v].weight;
        }
    }
    f[u] = max(f[u], maxg1 + maxg2);
}
```
我们从root开始进行DFS，最终的问题答案就是f[root]

### `最大权值和`子树
给定一棵树，每个点都有权值(可正可负)。求一个子树，使得权值最大。要求时间复杂度为O(n)

## 6.1~6.5 知识精练
### [HDU 1561 The more, The Better](http://acm.hdu.edu.cn/showproblem.php?pid=1561)
> 讲解：https://www.cnblogs.com/luyouqi233/p/8831338.html
### [HDU 1520 Anniversary party](http://acm.hdu.edu.cn/showproblem.php?pid=1520)
> 题解：也是POJ2342，
### [HDU 5593 ZYB's Tree](http://acm.hdu.edu.cn/showproblem.php?pid=5593)
### [POJ 2486 Apple Tree](http://poj.org/problem?id=2486)
### [HDU 3586 Information Disturbing](http://acm.hdu.edu.cn/showproblem.php?pid=3586)
### [CodeForces 960E Alternating Tree](https://www.luogu.com.cn/problem/CF960E)
