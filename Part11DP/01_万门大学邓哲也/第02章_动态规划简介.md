# 第02章 动态规划简介

## 2.1 动态规划的基本概念
> 阶段、状态、决策、策略、状态转移方程

### 1) 阶段和阶段变量
+ 将问题的全过程恰当地分成若干个相互联系的阶段
+ 阶段的划分一般根据时间和空间的自然特征去划分
+ 阶段的划分便于把问题转化成多阶段决策问题

### 2) 状态和状态变量
+ 通常一个阶段包含若干状态
+ 状态可由变量来描述

### 3) 决策、决策变量和决策允许集合
在对问题的处理中作出的每种选择性的行动就是决策

即从该阶段的每一个状态出发，通过一次选择性的行动转移至下一阶段的相应状态

一个实际问题可能需要有多次决策和多个决策点，在每一个阶段的每一个状态中都需要有一次决策，决策可以用变量来描述，称这种变量为决策变量

在实际问题中，决策变量的取值往往限制在某一个范围之内，此决策范围就称为决策允许集合

### 4) 策略和最优策略
所有阶段一次排列构成问题的全过程

全过程中各阶段决策变量所组成的有序总体称为策略，策略一般对应实际问题的一种解

在实际问题中，从允许决策集合中找出最优效果的策略称为最优策略，最优策略一般对应实际问题的最优解，这个也是大部分DP题目的目标

### 5) 状态转移方程
+ 前一阶段的终点的就是后一阶段的起点
+ 对前一阶段的状态做出某种决策，产生后一种阶段的状态
+ 这种关系描述了从i阶段到i+1阶段的演变规律，称为状态转移方程

> 结合上面总结的5个概念，来尝试解决两个问题

### 举例1：从n个数的数组a[n]中取出k个数，使得他们的和最大
> dp[i][j]表示从第1个数到第i个数之间，已经选取了j个数，其和最大的值

+ 阶段：前i个数
+ 状态：j，即选取了几个数，$0≤j≤i$
+ 决策：
  + A.取   第i个数到最终的j个数：`dp[i][j] = a[i] + dp[i - 1][j - 1]`
  + B.不取 第i个数到最终的j个数：`dp[i][j] = dp[i - 1][j]`
+ 策略：使得dp[i][j]尽量大，即取决策A和B的较大者
+ 状态转移方程：满足最优策略的方程，即`dp[i][j] = max{a[i] + dp[i - 1][j - 1], dp[i][j] = dp[i - 1][j]}`

### 举例2：从n个数的数组a[n]中找出最长上升子序列的元素个数
> `dp[i][j]`表示目前考虑了第1个到第i个数，且子序列中最后一个数是a[j]的最长上升子序列长度(`注意随着i的不同，j也会不同，子序列的长度和i、j不要混了`)
+ 阶段：前i个数
+ 状态：选取的子序列中的最后一个数a[j]
+ 决策：第i个数取或者不取
  + 取   第i个数：前i-1个数的最长上升子序列中的长度`dp[i - 1][j]`加1即为`dp[i][j]`(注意`dp[i - 1][j]`中的a[j]要小于a[i])，这样a[i]才能放到其后面，即`dp[i][j] =  1 + max{dp[i - 1][j] | 0 ≤ j ＜ i && a[j] ＜ a[i]}`
  + 不取 第i个数：此时前i个数的最长上升子序列和前i-1个数的最长上升子序列相同，即`dp[i][j] = dp[i - 1][j]`且`j ≠ a[i]`
+ 策略：使子序列的长度最长，即取上面两个决策的较大值。外层遍历i取最大值即为结果

题目见：[300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
> 题解：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/
```java
public class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxans = 1;
        for (int i = 1; i < dp.length; i++) {
            int maxval = 0;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) { // 要让nums[i]能放在最后，前面一个数必须小于nums[i]
                    maxval = Math.max(maxval, dp[j]);
                }
            }
            dp[i] = maxval + 1;
            maxans = Math.max(maxans, dp[i]);
        }
        return maxans;
    }
}
```
## 2.2 动态规划的性质
## 2.3 动态规划与记忆化搜索