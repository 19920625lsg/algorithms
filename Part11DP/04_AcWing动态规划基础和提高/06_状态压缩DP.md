# 06 状态压缩DP

## 一、蒙德里安的梦想
### 注意点
+ 1.本题等价于找到所有横放$1×2$小方格的方案数，因为一旦所有横放确定了，那么竖放方案是唯一的(只能按次序放)
+ 2.用$f[i][j]$记录第i列第j个状态(`第i列所有的行的格子存放情况`)。`j状态位等于1`表示上一列有横放格子(`整个j表示上一列的所有行横放格子的状态，1表示某行放格子了，0表示没有放格子`)，本列有格子捅出来。  
    转移方程很简单，本列的每一个状态都由上列所有“合法”状态转移过来$f[i][j] += f[i - 1][k]$，k表示上一列所有行的横放格子状态
+ 3.两个转移条件： 
  + $i$列和$i-1$列同一行不同时捅出来，否则转移的时候长度为2个格子的方块就会有重叠了
    > 本列捅出来的状态j和上列捅出来的状态k求`与`，为0才满足条件，即`(j & k) == 0`
  + 本列捅出来的状态j和上列捅出来的状态k求`或`，得到上列是否为奇数空行状态，奇数空行不转移，否则会导致竖向格子无法放置。即`j | k`的值不存在连续奇数个0

### 代码实现
```java
```java
import java.util.*;

// https://www.acwing.com/solution/content/7162/
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = 12, M = 1 << N; // 1左移N位，表示成某一列所有行的二进制状态即100000000000b即2^11=4096
        boolean[] st = new boolean[M];
        long[][] f;

        int n = sc.nextInt(), m = sc.nextInt();
        while (n != 0 && m != 0) {
            for (int i = 0; i < 1 << n; i++) {
                int count = 0;
                st[i] = true; // 假设当前状态时合法的
                for (int j = 0; j < n; j++) {
                    if ((i >> j & 1) == 1) {
                        if ((count & 1) == 1) st[i] = false; //第i个状态存在连续奇数个0，不合法
                        count = 0;
                    } else {
                        count++;
                    }
                }
                if ((count & 1) == 1) st[i] = false; // 最后的count也需要计算，这个容易忘
            }

            f = new long[N][M]; // 重置为0
            f[0][0] = 1; // base case很重要，第0列的上一列是没有的，绝对不会捅过来，所以只有1种方案
            for (int i = 1; i <= m; i++) { // 枚举所有的列
                for (int j = 0; j < 1 << n; j++) { // 枚举第i列的所有状态
                    for (int k = 0; k < 1 << n; k++) { // 枚举第i-1列的所有状态
                        if (st[(j | k)] && (j & k) == 0) f[i][j] += f[i - 1][k]; // 满足之前分析的两个转移条件，才能转移
                    }
                }
            }
            System.out.println(f[m][0]); // 最后一列没有任何捅出的了，即为最终结果
            // 更新下一轮的n和m
            n = sc.nextInt();
            m = sc.nextInt();
        }
    }
}
```
```