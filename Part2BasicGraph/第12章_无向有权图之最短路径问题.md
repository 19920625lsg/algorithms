# 第12章 无向有权图之最短路径问题

## 12.1 有权图的最短路径问题

### 什么是有权图的最短路径问题？
> 从图中的一个点到另一个点的路径中，权值总和最小的路径就是最短路径

### 最短路径的应用场景
+ 高德导航两个地点之间的路线，一般都是规划地最短路径
+ 互联网中对数据进行路由，一般都是选最优的路径进行数据传送

### 单源最短路径问题
![单源最短路径问题](https://img.mukewang.com/szimg/5e002511000161a217281080.jpg)

### 无权图有带权图的最短路径的区别
![无权图有带权图的区别](https://img.mukewang.com/szimg/5e0026b90001bd8d17281080.jpg)

### 求带权图的最短路径的算法
+ Dijkstra算法：不能处理负权边，处理负权边会使得复杂度上升
  > 实际大部分应用是不涉及负权边地，所以Dijkstra算法是够用地
+ Bellman-Ford算法：可以处理负权边
+ Floyd算法

## 12.2 Dijkstra算法的原理和模拟
![Dijkstra算法的原理](https://img.mukewang.com/szimg/5e0081010001a60517281080.jpg)
+ 1.根据上一个确定了到起始点最小值的节点，获取其到其所有还未被访问的邻接点路径，临时更新到表中(比原来地更小就更新，大于等于地话就不变)
+ 2.找到还没确定到起始点最小值的节点中距离值最小地,确定这个节点的当前大小就是最小距离，更新到表中
  > 这条是Dijkstra算法的核心

下面以下图为例，`选择0作为起始点`，模拟Dijkstra算法的详细过程，获取0到其他各个点的最短路径，
+ 确定了最小路径的就加粗
+ 不确定地就用斜体表示
![模拟Dijkstra算法的详细过程](https://img1.sycdn.imooc.com/szimg/5e006aee0001438717281080.jpg)
### 1.初始化0到各个顶点的距离均为`+∞`，Java中为`Integer.MAX_VALUE`
| 顶点标号 | 0  | 1  | 2  | 3  | 4  |
| -------- | -- | -- | -- | -- | -- |
| 最小距离 | +∞ | +∞ | +∞ | +∞ | +∞ |
### 2.遍历从0开始
+ 0到起始点的距离为0，**0到0的最小值确认为0**，直接设置到表中  
  | 顶点标号 | 0  | 1  | 2  | 3  | 4  |
  | -------- | -- | -- | -- | -- | -- |
  | 最小距离 | **0** | +∞ | +∞ | +∞ | +∞ |

### 3.访问0的`未确定到起始点最小距离值`的邻接点
+ 0的`未确定到起始点最小距离值`的邻接点1、2到0的距离分别为2和4，还不确定是到0的最小距离值，先把这两个临时最小距离值更新到表中
  | 顶点标号 | 0  | 1  | 2  | 3  | 4  |
  | -------- | -- | -- | -- | -- | -- |
  | 最小距离 | **0** | *4* | *2* | +∞ | +∞ |

+ `不确定到起始点最小距离值的顶点`1、2、3、4中，顶点2到起始点的0值最小，**所以0到2的最小值为2**，更新到表中 **这行是Dijkstra算法的核心**
  > 因为0到2以外的点的距离本来就都比2要大，又因为Dijkstra只考虑无负权边的图，所以经由其他顶点再到2的距离肯定会更大，故0到2的最短举例肯定是2

  | 顶点标号 | 0  | 1  | 2  | 3  | 4  |
  | -------- | -- | -- | -- | -- | -- |
  | 最小距离 | **0** | *4* | **2** | +∞ | +∞ |

### 4.访问2的`未确定到起始点最短距离值`的邻接点
+ 2的`未确定到起始点最小距离值`的邻接点1、3、4到2的距离分别为1、4、3，下面根据这些距离值更新对应的点到起始点的最小距离值(临时的，是不是最终的最小距离值等待后面确定)
  + `0到2的最小距离为2`+`2到1的距离为1`=3 < `上面表中0到1的距离为4`，所以更新0到1的临时最小距离为3
  + `0到2的最小距离为2`+`2到3的距离为4`=6 < `上面表中0到3的距离为∞`，所以更新0到3的临时最小距离为6
  + `0到2的最小距离为2`+`2到4的距离为5`=7 < `上面表中0到4的距离为∞`，所以更新0到4的临时最小距离为7
    | 顶点标号 | 0  | 1  | 2  | 3  | 4  |
    | -------- | -- | -- | -- | -- | -- |
    | 最小距离 | **0** | *3* | **2** | *6* | *7* |

+ `不确定到起始点最小距离值的顶点`1、3、4中，顶点1到起始点0的值3最小，**所以0到1的最小值确定为3**，更新到表中 **这行是Dijkstra算法的核心**
  > 因为0到1以外的点的距离本来就都比2要大(不考虑已经确认最小距离的顶点0和2，因为0到1就是从0->2->1过来地)，又因为Dijkstra只考虑无负权边的图，所以经由其他顶点再到1的距离肯定会更大，故0到1的最短举例肯定是3

  | 顶点标号 | 0  | 1  | 2  | 3  | 4  |
  | -------- | -- | -- | -- | -- | -- |
  | 最小距离 | **0** | **3** | **2** | *6* | *7* |

### 5.访问1的`未确定到起始点最小距离值`的邻接点
+ 1的`未确定到起始点最小距离值`的邻接点3、4到1的距离分别为2、3，下面根据这些距离值更新对应的点到起始点的最小距离值(临时的，是不是最终的最小距离值等待后面确定)
  + `0到1的最小距离为3`+`1到3的距离为2`=5 < `上面表中0到3的距离为6`，所以更新0到3的临时最小距离为5
  + `0到1的最小距离为3`+`1到4的距离为3`=6 < `上面表中0到4的距离为7`，所以更新0到4的临时最小距离为6
    | 顶点标号 | 0  | 1  | 2  | 3  | 4  |
    | -------- | -- | -- | -- | -- | -- |
    | 最小距离 | **0** | **3** | **2** | *5* | *6* |

+ `不确定到起始点最小距离值的顶点`3、4中，顶点3到起始点的0值最小，**所以0到3的最小值确定为5**，更新到表中 **这行是Dijkstra算法的核心**
  > 因为0到3以外的点的距离本来就都比5要大(不考虑已经确认最小距离的顶点0、2、1，因为0到3就是从0->2->1->3过来地)，又因为Dijkstra只考虑无负权边的图，所以经由其他顶点再到3的距离肯定会更大，故0到3的最短举例肯定是5

  | 顶点标号 | 0  | 1  | 2  | 3  | 4  |
  | -------- | -- | -- | -- | -- | -- |
  | 最小距离 | **0** | **3** | **2** | **5** | *6* |

### 6.访问3的`未确定到起始点最小距离值`的邻接点
+ 3的`未确定到起始点最小距离值的邻接点4到1的距离分别为1，下面根据这些距离值更新对应的点到起始点的最小距离值(临时的，是不是最终的最小距离值等待后面确定)
  + `0到3的最小距离为5`+`3到4的距离为1`=6 = `上面表中0到4的距离为6`，所以不用更新0到3的临时最小距离
    | 顶点标号 | 0  | 1  | 2  | 3  | 4  |
    | -------- | -- | -- | -- | -- | -- |
    | 最小距离 | **0** | **3** | **2** | **5** | *6* |

+ `不确定到起始点最小路径值的顶点`只剩4了，**所以0到4的最小值确定为6**，更新到表中 **这行是Dijkstra算法的核心**
  > 因为0到6以外的点的已经没了(不考虑已经确认最小距离的顶点0、2、1、3，因为0到6就是从0->2->1->3->6过来地)，故0到6的最小距离值为6
  
  | 顶点标号 | 0  | 1  | 2  | 3  | 4  |
  | -------- | -- | -- | -- | -- | -- |
  | 最小距离 | **0** | **3** | **2** | **5** | **6** |