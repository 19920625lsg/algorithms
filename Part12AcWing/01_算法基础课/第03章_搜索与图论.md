# 第03章 搜索与图论

## 九、Prim
### [AcWing 858.Prim算法求最小生成树](https://www.acwing.com/problem/content/860/)
```java
import java.io.*;
import java.util.*;

public class Main {
    private static int n, m;
    private static TreeMap<Integer, Integer>[] adj;
    private static int[] dist; // dist[i]表示上一个确定下来为最小生成树顶点的点到i的最小距离
    private static boolean[] st; // st是spanning tree的意思。st[i]为true表示顶点i已经确定为最终的最小生成树的一部分了
    private static final int INF = 0x3f3f3f3f;

    public static int prim() {
        int res = 0;
        // 每次都基于上一次的确定的位置找最短横切边
        for (int i = 0; i < n; i++) {
            int v = -1;
            // 每次都找最小权值点
            for (int w = 1; w <= n; w++) {
                if (!st[w] && (v == -1 || dist[w] < dist[v])) v = w;
            }
            if (i > 0 && dist[v] == INF) return INF;
            if (i > 0) res += dist[v]; // v确定为最小生成树的一个点了，结果中需要把边的权重加入进来
            for (int w = 1; w <= n; w++) {
                dist[w] = Math.min(dist[w], getWeight(v, w));
            }
            st[v] = true;
        }
        return res;
    }

    /* 添加边,在顶点v和顶点w之间建立一条边 */
    public static void addEdge(int v, int w, int weight) {
        // v=w会生成自环边
        if (v == w) return; // 自环直接跳过
        if (!hasEdge(v, w)) adj[v].put(w, weight); // 无重边直接插入
        else adj[v].put(w, Math.min(weight, adj[v].get(w))); // // 有重边，则用最小值进行更新
        // 无向图需要加两个边
        if (!hasEdge(w, v)) adj[w].put(v, weight); // 无重边直接插入
        else adj[w].put(v, Math.min(weight, adj[w].get(v))); // // 有重边，则用最小值进行更新
    }

    /* v和w之间是否存在边 */
    public static boolean hasEdge(int v, int w) {
        // v的邻接表中是否有w
        return adj[v].containsKey(w);
    }

    /* v和w之间的边的权重 */
    public static int getWeight(int v, int w) {
        if (hasEdge(v, w)) {
            return adj[v].get(w);
        }
        // 这条边不存在就返回个极大值，方便后面求最小生成树
        return INF;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        String[] s = b.readLine().split(" ");
        n = Integer.parseInt(s[0]); // n个顶点，下标从1开始
        m = Integer.parseInt(s[1]); // m条边，第3个参数是权值

        // 泛型数组需要强制转换，可以认为是Java语言的缺陷
        adj = (TreeMap<Integer, Integer>[]) new TreeMap[n + 1];
        for (int i = 1; i <= n; i++) adj[i] = new TreeMap<>(); // 初始化邻接表
        dist = new int[n + 1];
        Arrays.fill(dist, INF);
        st = new boolean[n + 1];

        // 添加边
        for (int i = 0; i < m; i++) {
            String[] edgeStr = b.readLine().split(" ");
            int v = Integer.parseInt(edgeStr[0]);
            int w = Integer.parseInt(edgeStr[1]);
            int weight = Integer.parseInt(edgeStr[2]);
            addEdge(v, w, weight);
        }
        int result = prim();
        if (result == INF) System.out.println("impossible");
        else System.out.println(result);
    }
}
```

## 十、Kruskal
### [AcWing 859.Kruskal算法求最小生成树](https://www.acwing.com/problem/content/861/)
```java
import java.io.*;
import java.util.*;

public class Main {
    private static int n, m;
    private static Edge[] edges;
    private static int[] parent;

    static class Edge {
        int v, w, weight;

        public Edge(int v, int w, int weight) {
            this.v = v;
            this.w = w;
            this.weight = weight;
        }
    }

    public static int kruskal() {
        for (int i = 1; i < n; i++) parent[i] = i;
        int res = 0, cnt = 0;
        for (int i = 0; i < m; i++) {
            int v = edges[i].v;
            int w = edges[i].w;
            int weight = edges[i].weight;
            v = find(v);
            w = find(w);
            if (v != w) {
                parent[v] = w;
                res += weight;
                cnt++;
            }
        }
        if (cnt < n - 1) return -1;
        else return res;
    }

    // 并查集，获取x所在树的根节点
    static int find(int x) {
        if (parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }

    public static void main(String[] args) throws IOException {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        String[] s = b.readLine().split(" ");
        n = Integer.parseInt(s[0]); // n个顶点，下标从1开始
        m = Integer.parseInt(s[1]); // m条边，第3个参数是权值
        edges = new Edge[m]; // m条边
        parent = new int[n + 1]; // 用于并查集，记录每个顶点的根节点

        // 添加边
        for (int i = 0; i < m; i++) {
            String[] edgeStr = b.readLine().split(" ");
            int v = Integer.parseInt(edgeStr[0]);
            int w = Integer.parseInt(edgeStr[1]);
            int weight = Integer.parseInt(edgeStr[2]);
            edges[i] = new Edge(v, w, weight);
        }

        // 贪心算法，按照边的权重排序
        Arrays.sort(edges, new Comparator<Edge>() {
            @Override
            public int compare(Edge edge1, Edge edge2) {
                return edge1.weight - edge2.weight;
            }
        });
        int result = kruskal();
        if (result == -1) System.out.println("impossible");
        else System.out.println(result);
    }
}
```

## 十一、染色法判定二分图
### [AcWing 860.染色法判定二分图](https://www.acwing.com/problem/content/862/)
```java
import java.io.*;
import java.util.*;

public class Main {
    private static List<Integer>[] adj;
    private static int n, m;
    private static boolean[] visited;
    private static int[] colors;
    private static boolean biPartition = true; // 默认是二分图


    /**
     * dfs过程中检测当前图是否是二分图
     *
     * @param v     当前的顶点
     * @param color v点的染色
     * @return 是否是二分图
     */
    private static boolean dfs(int v, int color) {
        visited[v] = true;
        colors[v] = color;
        for (Integer w : adj[v]) {
            if (!visited[w]) {
                // 颜色只有蓝(0)、绿(1)两种，w是v的邻接点，根据二分图的检测原理，w、v的颜色必须相反，只能一蓝一绿，蓝+绿 = 0 + 1 = 1,所以1-v的颜色 = 1-color = w的颜色
                if (!dfs(w, 1 - color)) {
                    // 返回false表示不是二分图
                    return false;
                }
            } else if (colors[w] == colors[v]) {
                // 如果w已经访问过，但是w作为v的邻接点和v的颜色相同，说明不是二分图
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        String[] s = b.readLine().split(" ");
        n = Integer.parseInt(s[0]); // n个顶点，下标从1开始
        m = Integer.parseInt(s[1]); // m条边，第3个参数是权值

        // 泛型数组需要强制转换，可以认为是Java语言的缺陷
        adj = (List<Integer>[]) new List[n + 1];
        for (int i = 1; i <= n; i++) adj[i] = new ArrayList<>(); // 初始化邻接表
        visited = new boolean[n + 1];
        colors = new int[n + 1];
        // 初始化colors为-1，后面检测到二分图会更新这个数组，会有0和1两种
        Arrays.fill(colors, -1);
        // 添加边
        for (int i = 0; i < m; i++) {
            String[] edgeStr = b.readLine().split(" ");
            int v = Integer.parseInt(edgeStr[0]);
            int w = Integer.parseInt(edgeStr[1]);
            if (v == w) continue;
            adj[v].add(w);
            adj[w].add(v);
        }

        // 从dfs(0)改成下面的代码，可以支持非连通的图,不用考虑连通分量的时候直接用dfs(v)即可
        for (int v = 1; v <= n; v++) {
            if (!visited[v]) {
                // 第一个节点染成蓝色(0)
                if (!dfs(v, 0)) {
                    // 某一个联通分量不是二分图，整个图就不是二分图了，直接返回，不再检测剩下的二分图了
                    biPartition = false;
                    // 一旦检测到不是二分图立马跳出，一定别忘
                    break;
                }
            }
        }
        System.out.println(biPartition ? "Yes" : "No");
    }
}
```

## 十二、匈牙利算法
### [AcWing 861.二分图的最大匹配](https://www.acwing.com/problem/content/863/)
```java
/**
解题思路：
寻找二分图的最大匹配问题思路就是遍历所有左边集合的点，
如果可以为它们找到一个匹配点，
结果++，主要的逻辑在find函数上。

时间复杂度分析：
二分图的匹配问题的理论时间复杂度很高，但是实际运行效率却很好，时间复杂度大致为O(n∗m)
*/
import java.util.*;
import java.io.*;

class Main{
    static int N = 510, M = 100010, n1,n2,m, idx;
    static int[] h = new int[N];
    static int[] e = new int[M], ne = new int[M];
    static int[] match = new int[M];//存储当前的节点匹配的节点的编号
    static boolean[] st = new boolean[M];//表示当前的这个节点是否访问过了

    static void add(int a, int b){
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    static boolean find(int t){
        for(int i=h[t]; i!=-1; i=ne[i]){
            int j = e[i];
            //访问过了 下一个
            if(st[j]) continue;
            st[j] = true;
            //如果当前节点没有任何匹配的对象,
            //或者, 还能找到另一个匹配对象. 
            if(match[j]==0 || find(match[j])){
                match[j] = t;
                return true;
            }
        }
        return false;
    }

    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        n1 = sc.nextInt();
        n2 = sc.nextInt();
        m = sc.nextInt();

        Arrays.fill(h, -1);

        while(m-->0){
            add(sc.nextInt(),sc.nextInt());
        }
        //记录匹配的个数
        int res = 0;
        for(int i=1;i<=n1;i++){
            Arrays.fill(st, false);
            if(find(i)) res++;
        }
        System.out.println(res);
    }
}
```