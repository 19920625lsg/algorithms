## 概念

单调栈就是**栈内元素单调递增或者单调递减的栈**，单调栈只能在**栈顶**操作。

## 详述
+ 1.单调栈里的元素具有单调性
+ 2.元素加入栈前，会在栈顶端把破坏栈单调性的元素都删除
+ 3.单调栈的维护是 O(n) 级的时间复杂度，因为所有元素只会进入栈一次，并且出栈后再也不会进栈了。

## 应用
> 单调栈可以用于解决如下问题（在一个数组中）。简言之就是
+ 找最近的比当前元素小的元素，维护一个`单调递增栈(栈底到栈顶递增)`
+ 找最近的比当前元素大的元素，维护一个`单调递减栈(栈底到栈顶递减)`

### 1.向左查找第一个比他小的元素
> 维护一个`单调递增栈(栈底到栈顶递增)`，从左向右遍历，遍历到的元素为a，栈顶元素为b
+ 1）当a > b时，将a插入栈顶，新的栈顶变成了a
+ 2）当a < b时，则将从栈顶位置向栈底查找(边查找，边把栈顶元素出栈)，直到找到第一个比a小的数，停止查找，把这个数返回，将元素a插入栈顶(即此时a找到了自己的位置)

```java
// 找出每个元素左边第一个比它小的元素
List<Integer> preSmallerElement(int[] nums) {
    Stack<Integer> st = new Stack<>();
    List<Integer> res = new ArrayList<>();
    for (int i = 0; i < nums.length; i++) {
        // 只要栈不为空，且栈顶元素不比x小，则弹出栈顶元素。每个元素入栈一次出栈一次，所以时间复杂度为O(1)
        while (!st.isEmpty() && nums[i] <= st.peek()) st.pop();
        int nearestMin = st.isEmpty() ? -1 : st.peek();
        res.add(nearestMin);
        st.push(nums[i]); // 插入x仍然保持住单调递增栈的特性
    }
    return res;
}
```
### 2.向左查找第一个比他大的元素
> 维护一个`单调递减栈(栈底到栈顶递减)`，从左向右遍历，遍历到的元素为a，栈顶元素为b
+ 1）当a < b时，将a插入栈顶，新的栈顶变成了a，返回b
+ 2）当a > b时则将从当前栈顶位置向前查找(边查找，边把栈顶元素出栈)，直到找到第一个比a大的数，停止查找，把这个数返回，将元素a插入栈顶(即此时a找到了自己的位置)

```python
class Solution:
    def preGreaterElement(self, nums):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        stack = list()
        res = [-1]*len(nums)
        for i, n in enumerate(nums):
            while stack and nums[stack[-1]] < n:
                stack.pop()
            if stack:
                res[i] = nums[stack[-1]]
            stack.append(i)
        return res
```

### 3.向右查找第一个比他小的元素
> 维护一个`单调递增栈(栈底到栈顶递增)`，从右向左遍历，遍历到的元素为a，栈顶元素为b
+ 1）当a > b时，将a插入栈顶，新的栈顶变成了a，返回b
+ 2）当a < b时，则将从栈顶位置向栈底查找(边查找，边把栈顶元素出栈)，直到找到第一个比a小的数，停止查找，把这个数返回，然后将a插入栈顶(即此时a找到了自己的位置)

```java
class Solution:
    def nextSmallerElement(self, nums):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        stack = list()
        res = [-1]*len(nums)
        for i, n in enumerate(nums):
            while stack and nums[stack[-1]] > n:
                res[stack.pop()] = n
            stack.append(i)
        return res

```

### 4.向右查找第一个比他大的元素
> 维护一个`单调递减栈(栈底到栈顶递减)`，从右向左遍历，遍历到的元素为a，栈顶元素为b
+ 1）当a < b时，将a插入栈顶，新的栈顶变成了a，返回b
+ 2）当a > b时则将从当前栈顶位置向前查找(边查找，边把栈顶元素出栈)，直到找到第一个比a大的数，停止查找，把这个数返回，将元素a插入栈顶(即此时a找到了自己的位置)

```python
class Solution:
    def nextGreaterElement(self, nums):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        stack = list()
        res = [-1]*len(nums)
        for i, n in enumerate(nums):
            while stack and nums[stack[-1]] < n: # 2
                res[stack.pop()] = n
            stack.append(i) # 1
        return res
```

> 注意：至于最后一点要说的就是，如何确定是使用严格单调栈还是非严格单调栈？（`数组中存在相等元素时，小于变成不大于，大于变成不小于`）只要根据题意确定我们栈中是否可以存放相同元素即可

## 题目
+ 1.向左查找第一个比他小的元素
  + [AcWing 830.单调栈](https://www.acwing.com/problem/content/832/)
+ 2.向左查找第一个比他大的元素
  + [Leetcode 901.股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)
  + [Leetcode 239.滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
+ 3.向右查找第一个比他小的元素
  + [Leetcode 84.柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
+ 4.向右查找第一个比他大的元素
  + [LeetCode 42.接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
  + [LeetCode 496.下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)
  + [LeetCode 503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)
  + [LeetCode 739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)