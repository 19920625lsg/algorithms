# 第06章 贪心算法
## 一、区间选点
> 题目链接：https://www.acwing.com/problem/content/description/907/

### 做法
+ 1.将每个区间按照右端点从小到大进行排序
+ 2.从前往后枚举每个区间，初始选定end值为无穷小
  + 2.1 若当前区间中包含该点end，则直接跳过
  + 2.2 否则，选择当前区间的右端点

### 贪心性质证明
+ 1.找到cnt个点，满足题意情况，则最优解$ans <= cnt$
+ 2.找到cnt个点，即找到cnt个区间，且区间从左到右依次排好且没有相同的交集(`一旦有两个区间有交集，那么至少有两个cnt的点可以合并成一个`)，则说明可能有区间没有被这cnt个点覆盖过，所以最优解$ans >= cnt$
+ 3.即$and == cnt$，证明完毕

### 代码实现
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return second - o.second;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new PII(sc.nextInt(), sc.nextInt())); // 根据左右端点创建PII对象
        }
        Collections.sort(list);
        int count = 0;
        int end = Integer.MIN_VALUE / 2;
        for (PII pii : list) {
            if (pii.first > end) {
                count++;
                end = pii.second;
            }
        }
        System.out.println(count);
    }
}
```

### 类似的题目：[803 区间合并](https://www.acwing.com/problem/content/description/805/)

## 二、最大不相交区间数量
> 题目链接：https://www.acwing.com/problem/content/910/
### 题目分析
> 最大不相交区间数==最少覆盖区间点数

为什么最大不相交区间数==最少覆盖区间点数呢？

因为如果几个区间能被同一个点覆盖，说明他们相交了，所以有几个点就是有几个不相交区间

因此本题的代码和上面那个题的代码完全一致

### 代码是和上面的题目完全相同
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return second - o.second;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new PII(sc.nextInt(), sc.nextInt())); // 根据左右端点创建PII对象
        }
        Collections.sort(list);
        int count = 0;
        int end = Integer.MIN_VALUE / 2;
        for (PII pii : list) {
            if (pii.first > end) {
                count++;
                end = pii.second;
            }
        }
        System.out.println(count);
    }
}
```

## 三、区间分组
> 题目链接：https://www.acwing.com/problem/content/description/908/
### 算法分析

+ 1、将所有区间按左端点从小到大排序
+ 2、从前往后枚举每个区间，判断能否将其放到某个现有的组中，即是否存在当前区间的的左端点L > 任意组中右端点的最小值的组
  + 2.1 如果不存在这样的组，则开新组，然后再将其放进组中
  + 2.2 如果存在这样的组，则将其放在符合条件的组中，并更新当前组的右端点的值
+ 3、为了不用每次选择组时都遍历所有组，可以通过小根堆来维护所有组中的尾端

### 证明：
+ 1、按照上述存放，一定是一种合法的方案，则Ans <= cnt
+ 2、由于分了cnt个组，则说明一定存在cnt个区间含有公共点，则一定至少开cnt个组，则Ans >= cnt
综合1、2可推出Ans == cnt

### 代码实现
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return first - o.first;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new PII(sc.nextInt(), sc.nextInt())); // 根据左右端点创建PII对象
        }
        Collections.sort(list); // 按照左端点进行排序
        Queue<Integer> pq = new PriorityQueue<>(); // 维护已合并区间的右端点，堆顶元素是最小值
        for (PII pii : list) {
            // 存在使得 当前区间的的左端点L > 任意组中右端点的最小值 的组，则更新最小堆
            if (!pq.isEmpty() && pii.first > pq.peek()) pq.remove();
            pq.add(pii.second);
        }
        System.out.println(pq.size());
    }
}
```