# 第06章 贪心算法

## LeetCode相关题目
### [527.单词缩写](https://leetcode-cn.com/problems/word-abbreviation)
```txt
给定一个由n个不重复非空字符串组成的数组，你需要按照以下规则为每个单词生成最小的缩写。

初始缩写由起始字母+省略字母的数量+结尾字母组成。
若存在冲突，亦即多于一个单词有同样的缩写，则使用更长的前缀代替首字母，直到从单词到缩写的映射唯一。换而言之，最终的缩写必须只能映射到一个单词。
若缩写并不比原单词更短，则保留原样。
示例:

输入: ["like", "god", "internal", "me", "internet", "interval", "intension", "face", "intrusion"]
输出: ["l2e","god","internal","me","i6t","interval","inte4n","f2e","intr4n"]
 

注意:

n和每个单词的长度均不超过 400。
每个单词的长度大于 1。
单词只由英文小写字母组成。
返回的答案需要和原数组保持同一顺序。
```

```java
// 首先给每个单词选择最短的缩写。然后我们对于所有重复的单词，我们增加这些重复项的长度。
// 参考：https://leetcode-cn.com/problems/word-abbreviation/solution/dan-ci-suo-xie-by-leetcode/
class Solution {
    private int[] prefixs;
    private Map<Integer, String> wordsCur;

    // 单词word需保留前prefix个字符以及最后一个字符中间的字符用end - prefix - 1来代替
    private String abbrev(String word, int prefix) {
        // prefix已经到了最后一个字符了，word已经不用变了
        if (prefix >= (word.length() - 1)) {
            return word;
        }
        return word.substring(0, prefix) + (word.length() - 1 - prefix) + word.substring(word.length() - 1);
    }

    // 查找重复单词，存在地话返回重复的单词的下标
    private Set<String> getRepeated() {
        Set<String> result = new HashSet<>();
        Map<String, Integer> wordCnt = new HashMap<>();
        for (int index : wordsCur.keySet()) {
            String word = wordsCur.get(index);
            if (wordCnt.get(word) == null) wordCnt.put(word, 1);
            else result.add(word); // 把重复出现的单词加入到结果中去
        }
        return result;
    }

    // 首先给每个单词选择最短的缩写。然后我们对于所有重复的单词，我们增加这些重复项的长度。
    public List<String> wordsAbbreviation(List<String> words) {
        wordsCur = new HashMap<>(); // 记录当前的单词
        prefixs = new int[words.size()];
        Arrays.fill(prefixs, 1); // 初始认为每个单词的前缀都只保留一个字符
        for (int i = 0; i < words.size(); i++) {
            wordsCur.put(i, abbrev(words.get(i), prefixs[i]));
        }
        // 查找重复单词
        Set<String> repeatedWords = getRepeated();
        while (repeatedWords.size() != 0) {
            for (int i = 0; i < words.size(); i++) {
                if (repeatedWords.contains(wordsCur.get(i))) {
                    prefixs[i]++; // 找到重复的单词就尝试把单词前缀长度+1
                    wordsCur.put(i, abbrev(words.get(i), prefixs[i])); // 更新单词缩写
                }
            }
            repeatedWords = getRepeated();
        }

        List<String> result = new ArrayList<>();
        for (Integer index : wordsCur.keySet()) {
            if (wordsCur.get(index).length() < words.get(index).length()) result.add(wordsCur.get(index));
            else result.add(words.get(index)); // 缩写后的单词长度比原来地还长，就把原来的单词加进去
        }
        return result;
    }
}
```

### [253.会议室 II](https://leetcode-cn.com/problems/meeting-rooms-ii/)
> https://leetcode-cn.com/problems/meeting-rooms-ii/solution/hui-yi-shi-ii-by-leetcode/

```txt
给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],...] (si < ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。

示例 1:

输入: [[0, 30],[5, 10],[15, 20]]
输出: 2
示例 2:

输入: [[7,10],[2,4]]
输出: 1
```

**算法**

+ 1. 按照 开始时间 对会议进行排序。
+ 2. 初始化一个新的 最小堆，将第一个会议的结束时间加入到堆中。我们只需要记录会议的结束时间，告诉我们什么时候房间会空。
+ 3. 对每个会议，检查堆的最小元素（即堆顶部的房间）是否空闲。
   + 3.1. 若房间空闲，则从堆顶拿出该元素，将其改为我们处理的会议的结束时间，加回到堆中。
   + 3.2. 若房间不空闲。开新房间，并加入到堆中。
+ 4. 处理完所有会议后，堆的大小即为开的房间数量。这就是容纳这些会议需要的最小房间数。

```java
// https://leetcode-cn.com/problems/meeting-rooms-ii/solution/hui-yi-shi-ii-by-leetcode/
class Solution {
    static class PII implements Comparable<PII> {
        int first, second; // 会议的开始时间和结束时间

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return first - o.first;
        }
    }

    public int minMeetingRooms(int[][] intervals) {
        List<PII> list = new ArrayList<>();
        for (int[] interval : intervals) {
            list.add(new PII(interval[0], interval[1])); // 根据左右端点创建PII对象
        }
        Collections.sort(list); // 按照会议开始时间排序
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (PII pii : list) {
            if (pq.isEmpty()) {
                pq.add(pii.second); // 加入结束时间
                continue;
            }
            if (pii.first >= pq.peek()) { // 新的会议开始时间在前面的最早结束的会议的后面，因此可以排在其后面，会议室并没有增加 
                pq.remove(); // 弹出之前已经结束的最早的会议
                pq.add(pii.second); // 把当前的会议的结束时间加进去，表示占住了上面那个结束的会议室
            } else { // // 新的会议开始时间在前面的最早结束的会议的前面，没办法，只能加会议室了
                pq.add(pii.second);
            }
        }
        return pq.size();
    }
}
```



## 七、货仓选址
> 题目链接：https://www.acwing.com/problem/content/106/ 题解链接：https://www.acwing.com/solution/content/5382/

### 题目分析
+ 1、把$A[0]$~$A[N-1]$排序，设货仓在X坐标处，X左侧的商店有P家，右侧的商店有Q家。
  + 若P < Q，则每把仓库的选址向右移动1单位距离，距离之和就会变少Q - P.
  + 同理，若P > Q，则仓库的选址向左移动会使距离之和变小。
  + 显然：当P==Q时为最优解。

+ 2、因此仓库应该建在中位数处，把A进行排序，
  + 当N为奇数时，货仓建在A[(N - 1)/2]处，
  + 当N为偶数时，仓库建在A[(N - 1)/2 + 1]处。

为了统一情况，一致建立在$(n - 1) / 2$位置上

![图示](https://cdn.acwing.com/media/article/image/2019/10/16/7416_3d3c4ea8f0-c6ac75db78d92ebfaf0d7930419bd12.png)

### 代码实现
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] A = new int[n];
        for(int i = 0; i < n; i++) A[i] = sc.nextInt();
        Arrays.sort(A);
        int mid = (n - 1) / 2;
        int sum = 0;
        for(int i = 0; i < n; i++) sum += Math.abs(A[mid] - A[i]);
        System.out.println(sum);
    }
}
```

## 八、耍杂技的牛
> 题目地址：https://www.acwing.com/problem/content/127/ 题解地址：https://www.acwing.com/solution/content/845/
### 算法分析
与国王游戏的贪心策略相似， 我们先分析
$$每头牛的危险值 = 他前面牛的w(重量值)和 - 自身的s(强壮值)$$，
要使每头牛的危险值最小，这显然是与w 和 s同时相关，所以先 yy 出一种做法按 `每头牛的w + s进行升序排序`(**题见多了可能就会有这种题感**)。

接下来进行数学分析证明:

| 牛   | 交换前                     | 交换后 |
| ---- | -------------------------- | ------ |
| $i$  | $\sum_{j=1}^{i-1}w_j - s_i$ | $\sum_{j=1}^{i-1}w_j + w_{i+1}- s_i$ |
| $i+1$ | $\sum_{j=1}^{i}w_j - s_{i+1}$ | $\sum_{j=1}^{i-1}w_j - s_{i+1}$ |

其他牛的危险值显然不变，所以分析`交换前后这两头牛中最大的危险值`即可。

将上述式子进行化简，每个式子减去 $\sum^{i−1}_{j=1}w_j$得到如下式子

| 牛   | 交换前                     | 交换后 |
| ---- | -------------------------- | ------ |
| $i$  | $-s_i$ | $w_{i+1}- s_i$ |
| $i+1$ | $w_i - s_{i+1}$ | $-s_{i+1}$ |

由于s, w都是正数，$w_i−s_{i+1}>−s_{i+1} , w_{i+1}−s_i>−s_i$
比较$w_i−s_{i+1}, w_{i+1}−s_i$即可

当$w_i−s_{i+1}>=w_{i+1}−s_i$，即 $w_i+s_i>=w_{i+1}+s_{i+1}$时, 交换后更优

当$wi−s_{i+1}<w_{i+1}−si$，即 $w_i+s_i<w_{i+1}+s_{i+1}$时, 交换前更优

> 所以得到做法: `按每头牛的 w + s 进行排序, 当存在逆序时就进行交换(即升序排序)`，然后根据题意算出每头牛的危险值记录其中的最大值即可

### 代码实现
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return first - o.first;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int w = sc.nextInt();
            int s = sc.nextInt();
            list.add(new PII(w + s, w));
        }
        Collections.sort(list);
        int res = Integer.MIN_VALUE;
        int sum = 0; // 记录危险值
        for(PII pii : list) {
            int w = pii.second;
            int s = pii.first - w;
            res = Math.max(res, sum -s);
            sum += w;
        }
        System.out.println(res);
    }
}
```