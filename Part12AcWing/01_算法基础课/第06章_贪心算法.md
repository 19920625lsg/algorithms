# 第06章 贪心算法
## 一、区间选点
> 题目链接：https://www.acwing.com/problem/content/description/907/

### 做法
+ 1.将每个区间按照右端点从小到大进行排序
+ 2.从前往后枚举每个区间，初始选定end值为无穷小
  + 2.1 若当前区间中包含该点end，则直接跳过
  + 2.2 否则，选择当前区间的右端点

### 贪心性质证明
+ 1.找到cnt个点，满足题意情况，则最优解$ans <= cnt$
+ 2.找到cnt个点，即找到cnt个区间，且区间从左到右依次排好且没有相同的交集(`一旦有两个区间有交集，那么至少有两个cnt的点可以合并成一个`)，则说明可能有区间没有被这cnt个点覆盖过，所以最优解$ans >= cnt$
+ 3.即$and == cnt$，证明完毕

### 代码实现
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return second - o.second;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new PII(sc.nextInt(), sc.nextInt())); // 根据左右端点创建PII对象
        }
        Collections.sort(list);
        int count = 0;
        int end = Integer.MIN_VALUE / 2;
        for (PII pii : list) {
            if (pii.first > end) {
                count++;
                end = pii.second;
            }
        }
        System.out.println(count);
    }
}
```

### 类似的题目：[803 区间合并](https://www.acwing.com/problem/content/description/805/)

## 二、最大不相交区间数量

### 题目分析
> 最大不相交区间数==最少覆盖区间点数

为什么最大不相交区间数==最少覆盖区间点数呢？

因为如果几个区间能被同一个点覆盖，说明他们相交了，所以有几个点就是有几个不相交区间

因此本题的代码和上面那个题的代码完全一致

### 代码是和上面的题目完全相同
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return second - o.second;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new PII(sc.nextInt(), sc.nextInt())); // 根据左右端点创建PII对象
        }
        Collections.sort(list);
        int count = 0;
        int end = Integer.MIN_VALUE / 2;
        for (PII pii : list) {
            if (pii.first > end) {
                count++;
                end = pii.second;
            }
        }
        System.out.println(count);
    }
}
```