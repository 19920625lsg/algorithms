# 10.DFS之剪枝与优化

## 搜索的常见剪枝策略：
+ 1）求最大值 or 最小值，一旦中间某种状态的值**大于已有的最小值**(`后续还会继续增大`)或者**小于已有的最大值**(`后续还会继续减少`)，则可以直接退出
+ 2）求方案数的问题，可以用记忆数组把每个方案的visited标记为true，这样下次访问到这种状态可以直接跳过


## 题目
### [AcWing 165.小猫爬山](https://www.acwing.com/problem/content/167/)
> 未剪枝的代码，和[AcWing 1118.分成互质组](09_DFS之搜索顺序.md#acwing-1118分成互质组) 完全一样的思路
```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 和 AcWing 1118.分成互质组 非常相似
 */
class Main {
    static int N; // 猫的数量
    static int W; // 缆车的数量
    static int[] weights; // 每只猫的重量
    static List<Integer>[] cables;

    static int res = 18; // 求最少的缆车数，那么要初始化为最大的缆车数
    static int cableCnt = 0; // 需要的缆车数，在DFS和回溯过程中动态更新

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt(); // N只猫
        W = sc.nextInt(); // 每个缆车的上限
        weights = new int[N]; // 存储每个猫的重量
        for (int i = 0; i < N; i++) {
            weights[i] = sc.nextInt();
        }
        cables = new List[18]; // 最多18只猫，因为每个猫的重量都小于缆车钟朗最多也就18个。cables[i]表示第i辆缆车装了多少只猫
        for (int i = 0; i < 18; i++) {
            cables[i] = new ArrayList<>();
        }
        dfs(0);
        System.out.println(res);
    }

    // 枚举每一只猫属于哪一个缆车
    private static void dfs(int index) {
        if (index == N) { // 枚举完所有的猫了，统计一下当前使用的缆车数
            res = Math.min(res, cableCnt);
            return;
        }

        for (int i = 0; i < cableCnt; i++) {
            if (check(cables[i], index)) { // 计算把第index只猫加入第i个缆车后，缆车是否会超重
                cables[i].add(index); // 注意记录地是索引！
                dfs(index + 1); // 千万不要用index++，因为会改变index
                cables[i].remove(cables[i].size() - 1); // 回溯过程中删除之前加入的元素
            }
        }

        // 没有缆车能装下当前index对应的猫了，那么就需要新开一个缆车了
        cables[cableCnt].add(index);
        cableCnt++;
        dfs(index + 1);
        cableCnt--; // 回溯需要删去之前加地缆车，可以看出回溯前和回溯后，代码是对称地
        cables[cableCnt].remove(cables[cableCnt].size() - 1);
    }

    private static boolean check(List<Integer> cable, int index) {
        int sum = 0;
        for (int i : cable) {
            sum += weights[i];
        }
        return sum + weights[index] <= W;
    }
}
```

> 剪枝：只要中间遍历到某个状态的缆车数多于前面得到过的缆车数，就可以提前退出了，再考虑更多的缆车数也没有意义了

其实就是加了一句`if (cableCnt >= res) return;`

```java
import java.util.*;

/**
 * 和 AcWing 1118.分成互质组 非常相似
 */
class Main {
    static int N; // 猫的数量
    static int W; // 缆车的数量
    static int[] weights; // 每只猫的重量
    static List<Integer>[] cables;

    static int res = 18; // 求最少的缆车数，那么要初始化为最大的缆车数
    static int cableCnt = 0; // 需要的缆车数，在DFS和回溯过程中动态更新

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt(); // N只猫
        W = sc.nextInt(); // 每个缆车的上限
        weights = new int[N]; // 存储每个猫的重量
        for (int i = 0; i < N; i++) {
            weights[i] = sc.nextInt();
        }
        cables = new List[18]; // 最多18只猫，因为每个猫的重量都小于缆车，因此最多也就18个缆车。cables[i]表示第i辆缆车装了多少只猫
        for (int i = 0; i < 18; i++) {
            cables[i] = new ArrayList<>();
        }

        dfs(0);
        System.out.println(res);
    }

    // 枚举每一只猫属于哪一个缆车
    private static void dfs(int index) {
        if (index == N) { // 枚举完所有的猫了，统计一下当前使用的缆车数
            res = Math.min(res, cableCnt);
            return;
        }

        if (cableCnt >= res) return; // 如果现在的缆车数已经超过了前面最少地了，直接退出，核心的剪枝策略

        for (int i = 0; i < cableCnt; i++) {
            if (check(cables[i], index)) { // 计算把第index只猫加入第i个缆车后，缆车是否会超重
                cables[i].add(index); // 注意记录地是索引！
                dfs(index + 1); // 千万不要用index++，因为会改变index
                cables[i].remove(cables[i].size() - 1); // 回溯过程中删除之前加入的元素
            }
        }

        // 没有缆车能装下当前index对应的猫了，那么就需要新开一个缆车了
        cables[cableCnt].add(index);
        cableCnt++;
        dfs(index + 1);
        cableCnt--; // 回溯需要删去之前加地缆车，可以看出回溯前和回溯后，代码是对称地
        cables[cableCnt].remove(cables[cableCnt].size() - 1);
    }

    private static boolean check(List<Integer> cable, int index) {
        int sum = 0;
        for (int i : cable) {
            sum += weights[i];
        }
        return sum + weights[index] <= W;
    }
}
```

### [AcWing 166.数独](https://www.acwing.com/problem/content/168/)
### [AcWing 167.木棒](https://www.acwing.com/problem/content/169/)
### [AcWing 168.生日蛋糕](https://www.acwing.com/problem/content/170/)