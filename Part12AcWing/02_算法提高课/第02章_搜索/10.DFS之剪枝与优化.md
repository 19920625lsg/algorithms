# 10.DFS之剪枝与优化

## 搜索的常见剪枝策略：
+ 1）求最大值 or 最小值，一旦中间某种状态的值**大于已有的最小值**(`后续还会继续增大`)或者**小于已有的最大值**(`后续还会继续减少`)，则可以直接退出
+ 2）求方案数的问题，可以用记忆数组把每个方案的visited标记为true，这样下次访问到这种状态可以直接跳过


## 题目
### [AcWing 165.小猫爬山](https://www.acwing.com/problem/content/167/)
> 未剪枝的代码，和[AcWing 1118.分成互质组](09_DFS之搜索顺序.md#acwing-1118分成互质组) 完全一样的思路
```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 和 AcWing 1118.分成互质组 非常相似
 */
class Main {
    static int N; // 猫的数量
    static int W; // 缆车的数量
    static int[] weights; // 每只猫的重量
    static List<Integer>[] cables;

    static int res = 18; // 求最少的缆车数，那么要初始化为最大的缆车数
    static int cableCnt = 0; // 需要的缆车数，在DFS和回溯过程中动态更新

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt(); // N只猫
        W = sc.nextInt(); // 每个缆车的上限
        weights = new int[N]; // 存储每个猫的重量
        for (int i = 0; i < N; i++) {
            weights[i] = sc.nextInt();
        }
        cables = new List[18]; // 最多18只猫，因为每个猫的重量都小于缆车钟朗最多也就18个。cables[i]表示第i辆缆车装了多少只猫
        for (int i = 0; i < 18; i++) {
            cables[i] = new ArrayList<>();
        }
        dfs(0);
        System.out.println(res);
    }

    // 枚举每一只猫属于哪一个缆车
    private static void dfs(int index) {
        if (index == N) { // 枚举完所有的猫了，统计一下当前使用的缆车数
            res = Math.min(res, cableCnt);
            return;
        }

        for (int i = 0; i < cableCnt; i++) {
            if (check(cables[i], index)) { // 计算把第index只猫加入第i个缆车后，缆车是否会超重
                cables[i].add(index); // 注意记录地是索引！
                dfs(index + 1); // 千万不要用index++，因为会改变index
                cables[i].remove(cables[i].size() - 1); // 回溯过程中删除之前加入的元素
            }
        }

        // 没有缆车能装下当前index对应的猫了，那么就需要新开一个缆车了
        cables[cableCnt].add(index);
        cableCnt++;
        dfs(index + 1);
        cableCnt--; // 回溯需要删去之前加地缆车，可以看出回溯前和回溯后，代码是对称地
        cables[cableCnt].remove(cables[cableCnt].size() - 1);
    }

    private static boolean check(List<Integer> cable, int index) {
        int sum = 0;
        for (int i : cable) {
            sum += weights[i];
        }
        return sum + weights[index] <= W;
    }
}
```

> 剪枝：只要中间遍历到某个状态的缆车数多于前面得到过的缆车数，就可以提前退出了，再考虑更多的缆车数也没有意义了

其实就是加了一句`if (cableCnt >= res) return;`

```java
import java.util.*;

/**
 * 和 AcWing 1118.分成互质组 非常相似
 */
class Main {
    static int N; // 猫的数量
    static int W; // 缆车的数量
    static int[] weights; // 每只猫的重量
    static List<Integer>[] cables;

    static int res = 18; // 求最少的缆车数，那么要初始化为最大的缆车数
    static int cableCnt = 0; // 需要的缆车数，在DFS和回溯过程中动态更新

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt(); // N只猫
        W = sc.nextInt(); // 每个缆车的上限
        weights = new int[N]; // 存储每个猫的重量
        for (int i = 0; i < N; i++) {
            weights[i] = sc.nextInt();
        }
        cables = new List[18]; // 最多18只猫，因为每个猫的重量都小于缆车，因此最多也就18个缆车。cables[i]表示第i辆缆车装了多少只猫
        for (int i = 0; i < 18; i++) {
            cables[i] = new ArrayList<>();
        }

        dfs(0);
        System.out.println(res);
    }

    // 枚举每一只猫属于哪一个缆车
    private static void dfs(int index) {
        if (index == N) { // 枚举完所有的猫了，统计一下当前使用的缆车数
            res = Math.min(res, cableCnt);
            return;
        }

        if (cableCnt >= res) return; // 如果现在的缆车数已经超过了前面最少地了，直接退出，核心的剪枝策略

        for (int i = 0; i < cableCnt; i++) {
            if (check(cables[i], index)) { // 计算把第index只猫加入第i个缆车后，缆车是否会超重
                cables[i].add(index); // 注意记录地是索引！
                dfs(index + 1); // 千万不要用index++，因为会改变index
                cables[i].remove(cables[i].size() - 1); // 回溯过程中删除之前加入的元素
            }
        }

        // 没有缆车能装下当前index对应的猫了，那么就需要新开一个缆车了
        cables[cableCnt].add(index);
        cableCnt++;
        dfs(index + 1);
        cableCnt--; // 回溯需要删去之前加地缆车，可以看出回溯前和回溯后，代码是对称地
        cables[cableCnt].remove(cables[cableCnt].size() - 1);
    }

    private static boolean check(List<Integer> cable, int index) {
        int sum = 0;
        for (int i : cable) {
            sum += weights[i];
        }
        return sum + weights[index] <= W;
    }
}
```

### [AcWing 166.数独](https://www.acwing.com/problem/content/168/)
> 自己的还没做完
```java
import java.util.*;

class Main {
    static char[][] grid;
    static int R = 9;
    static int C = 9;
    static int unPlacedCnt = 0; // 还没有放置好位置的元素
    static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}};
    static final char[] chs = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};

    static boolean inGrid(int r, int c) {
        return r >= 0 && r < R && c >= 0 && c < C;
    }

    private static void dfs(int rCur, int cCur) {
        if (unPlacedCnt == 0) { // 所有没放置的位置都安排好了，直接返回即可
            return;
        }

        // 尝试填[rCur, cCur]周围的8个位置，不断往下递归
        for (int[] dir : dirs) {
            int rNext = rCur + dir[0];
            int cNext = cCur + dir[1];
            if (inGrid(rNext, cNext) && grid[rNext][cNext] != '.') { // 没防止过数字才能尝试占用
                List<Character> canPlaceList = place(rCur, cCur); // 尝试在当前位置防止1到9，满足条件的放到canPlaceList里
                for (char numChar : canPlaceList) { // 枚举当前位置可以放置的元素
                    grid[rNext][cNext] = numChar;
                    unPlacedCnt--;
                    dfs(rNext, cNext);
                    grid[rNext][cNext] = '.'; // 回溯过程中把放置的数字改回去
                    unPlacedCnt++; // 未放置的点个数+1
                }
            }
        }
    }

    /**
     * 在现有grid的情况下为了满足数独限制可以在位置(r, c)放置哪些字符
     */
    private static List<Character> place(int r, int c) {
        List<Character> result = new ArrayList<>();
        boolean[] visited = new boolean[256]; // 记录1~9这几个字符的放置情况
        // Todo：1.检查[r, c]所在行

        // Todo：2.检查[r, c]所在列

        // Todo：3.检查[r, c]所在的每个3 × 3的九宫格内
        return null;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line = "";
        grid = new char[R][C];
        while (!(line = sc.nextLine()).equals("end")) {
            char[] lineChs = line.toCharArray();
            for (int i = 0; i < R * C; i++) {
                grid[i / C][i % R] = lineChs[i]; // 拆分成二维矩阵
                if (lineChs[i] == '.') unPlacedCnt++;
            }
            for (int r = 0; r < R; r++) {
                for (int c = 0; c < C; c++) {
                    if (grid[r][c] != '.') {
                        dfs(r, c); // 从已经填充的任何点开始DFS，找到方案了返回即可
                        break;
                    }
                }
            }
            // 输出grid即可
            for (int r = 0; r < R; r++) {
                for (int c = 0; c < C; c++) {
                    System.out.print(grid[r][c]); // 输出所有放置好后的字符
                }
            }
        }
    }
}
```

> 找了个参考答案：https://www.acwing.com/solution/content/7208/

```java
// 1.dfs 顺序 “选择一个可选答案填入” -> “优先选备选方案少的”
// 2.dfs 状态 “剩余要填几个格子”
// 3.剪枝  3.1 动态选  “优先选备选方案少的”
//         3.2 位运算存状态减少常数

import java.util.*;


public class Main {

    void run() {
        for (int i = 0; i < N; i++) map[1 << i] = i;
        for (int i = 0; i < (1 << N); i++) {
            for (int j = i; j > 0; j -= lowBit(j)) {
                ones[i]++;
            }
        }

        while (true) {
            String sd = jin.next();
            if (sd.equals("end")) break;
            System.out.println(solve(sd));
        }
    }

    int lowBit(int x) {
        return x & -x;
    }

    int init(char[] sudoku) {

        for (int i = 0; i < N; i++) {
            cell[i] = row[i] = col[i] = (1 << N) - 1;
        }

        int count = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (sudoku[i * N + j] != '.') {
                    int index = sudoku[i * N + j] - '1';
                    flip(i, j, 1 << index);
                } else {
                    count++;
                }
            }
        }
        return count;
    }

    int getStatus(int x, int y) {
        return row[x] & col[y] & cell[getIndex(x, y)];
    }

    int getIndex(int x, int y) {
        return x / 3 * 3 + y / 3;
    }


    void flip(int x, int y, int value) {
        row[x] ^= value;
        col[y] ^= value;
        cell[getIndex(x, y)] ^= value;
    }

    String solve(String sd) {
        sudoku = sd.toCharArray();
        int count = init(sudoku);
        dfs(count);
        return new String(sudoku);
    }


    boolean dfs(int count) {

        if (count == 0) return true;

        // 获取备选答案最少的点
        int minNumbers = 10;
        int x = -1;
        int y = -1;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (sudoku[i * N + j] != '.') continue;
                int status = getStatus(i, j);
                if (status == 0) return false;  // 再剪一下

                int numbers = ones[status];
                if (numbers < minNumbers) {
                    minNumbers = numbers;
                    x = i;
                    y = j;
                }

            }
        }

        //遍历所有可能
        for (int i = getStatus(x, y); i > 0; i -= lowBit(i)) {
            int candidate = map[lowBit(i)];
            int value = 1 << candidate;
            flip(x, y, 1 << candidate);
            sudoku[x * N + y] = (char) ((char) candidate + '1');
            // dfs(count - 1);
            if (dfs(count - 1)) return true;
            flip(x, y, 1 << candidate);
            sudoku[x * N + y] = '.';
        }

        return false;
    }

    private int N = 9;
    char[] sudoku;
    private int[] row = new int[N];
    private int[] col = new int[N];
    private int[] cell = new int[N];
    private int[] ones = new int[1 << N];
    private int[] map = new int[1 << N];

    private Scanner jin = new Scanner(System.in);

    public static void main(String[] args) throws Exception {
        new Main().run();
    }
}
```
### [AcWing 167.木棒](https://www.acwing.com/problem/content/169/)
### [AcWing 168.生日蛋糕](https://www.acwing.com/problem/content/170/)